---
title: "DynamoRIO eXtension utilities"
layout: default
permalink: /group__drx.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DynamoRIO eXtension utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga48c78ac1ff92549afbe94c26369e168e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga48c78ac1ff92549afbe94c26369e168e">DRMGR_PRIORITY_NAME_DRX_FAULT</a>&#160;&#160;&#160;&quot;drx_fault&quot;</td></tr>
<tr class="separator:ga48c78ac1ff92549afbe94c26369e168e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c12b3b71826d8b412f25a0059fd2017"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga1c12b3b71826d8b412f25a0059fd2017">DRX_FILE_SKIP_OPEN</a>&#160;&#160;&#160;0x8000</td></tr>
<tr class="separator:ga1c12b3b71826d8b412f25a0059fd2017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0645733e06c68e965ccc9e7c3126d438"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga0645733e06c68e965ccc9e7c3126d438">DRMGR_PRIORITY_NAME_DRX_BUF_INIT</a>&#160;&#160;&#160;&quot;drx_buf.init&quot;</td></tr>
<tr class="separator:ga0645733e06c68e965ccc9e7c3126d438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ddda40d50adc634c87223c1dd474a3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga6ddda40d50adc634c87223c1dd474a3e">DRMGR_PRIORITY_NAME_DRX_BUF_EXIT</a>&#160;&#160;&#160;&quot;drx_buf.exit&quot;</td></tr>
<tr class="separator:ga6ddda40d50adc634c87223c1dd474a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8006198d0e3f3f85df687e9286de597c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga8006198d0e3f3f85df687e9286de597c">drx_buf_full_cb_t</a>) (void *drcontext, void *buf_base, size_t size)</td></tr>
<tr class="separator:ga8006198d0e3f3f85df687e9286de597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839a0a82cdb05bc4285369d905e3daaf"><td class="memItemLeft" align="right" valign="top">typedef struct _drx_buf_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a></td></tr>
<tr class="separator:ga839a0a82cdb05bc4285369d905e3daaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0944a4353780132eeab7b06e3e42291d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__drx.html#gga0944a4353780132eeab7b06e3e42291da8cd3adf4599b9be81a32a0d111df47ed">DRMGR_PRIORITY_FAULT_DRX</a> = -7500
 }</td></tr>
<tr class="separator:ga0944a4353780132eeab7b06e3e42291d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4caf8d8f829279fba122163d961608a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4a507636af18a8858c214066682d013a1a">DRX_COUNTER_64BIT</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4aa50fccbd9d5dc9f300d6033c971f95e4">DRX_COUNTER_REL_ACQ</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4aa45e32a1d62398b84858de6759364688">DRX_COUNTER_LOCK</a> = 0x10
<br />
 }</td></tr>
<tr class="separator:ga4caf8d8f829279fba122163d961608a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a58e29e8dbf2b5bdeb775cba46556e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__drx.html#gga96a58e29e8dbf2b5bdeb775cba46556ea72c2469ba268615b188959b3ffbef685">DRX_BUF_FAST_CIRCULAR_BUFSZ</a> = (1 &lt;&lt; 16)
 }</td></tr>
<tr class="separator:ga96a58e29e8dbf2b5bdeb775cba46556e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48899087cc647f0f791ed0c459adc53"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__drx.html#ggab48899087cc647f0f791ed0c459adc53ad97fe2f57b9c6ec96fd3b8461b0cfeb1">DRMGR_PRIORITY_THREAD_INIT_DRX_BUF</a> = -7500, 
<br />
&#160;&#160;<a class="el" href="group__drx.html#ggab48899087cc647f0f791ed0c459adc53a2c71daa1f7dc4665d5e32997578809c0">DRMGR_PRIORITY_THREAD_EXIT_DRX_BUF</a> = -7500
<br />
 }</td></tr>
<tr class="separator:gab48899087cc647f0f791ed0c459adc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae0665a86427616ffc80c59375649e283"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#gae0665a86427616ffc80c59375649e283">drx_init</a> (void)</td></tr>
<tr class="separator:gae0665a86427616ffc80c59375649e283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996c662c089046984b64a627500748f5"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga996c662c089046984b64a627500748f5">drx_exit</a> (void)</td></tr>
<tr class="separator:ga996c662c089046984b64a627500748f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3189cbfbf85d5c32965bd8a140b2c35e"><td class="memItemLeft" align="right" valign="top">DR_EXPORT ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga3189cbfbf85d5c32965bd8a140b2c35e">drx_reserve_note_range</a> (size_t size)</td></tr>
<tr class="separator:ga3189cbfbf85d5c32965bd8a140b2c35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33a91872caa46e430d5d721af6d8c82"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#gae33a91872caa46e430d5d721af6d8c82">drx_aflags_are_dead</a> (<a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:gae33a91872caa46e430d5d721af6d8c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eba10b0f9536c1a108d796e0b84c4cd"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga5eba10b0f9536c1a108d796e0b84c4cd">drx_insert_counter_update</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot, IF_NOT_X86_(<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot2) void *addr, int value, uint flags)</td></tr>
<tr class="separator:ga5eba10b0f9536c1a108d796e0b84c4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9348e840424caf0098a8b1ba69955864"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga9348e840424caf0098a8b1ba69955864">drx_register_soft_kills</a> (bool(*event_cb)(process_id_t pid, int exit_code))</td></tr>
<tr class="separator:ga9348e840424caf0098a8b1ba69955864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f2b2e6468760cdee7c55975e8cdce5c"><td class="memItemLeft" align="right" valign="top">DR_EXPORT size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga2f2b2e6468760cdee7c55975e8cdce5c">drx_instrlist_size</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist)</td></tr>
<tr class="separator:ga2f2b2e6468760cdee7c55975e8cdce5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ced61bc9752b42236f79929a3daf830"><td class="memItemLeft" align="right" valign="top">DR_EXPORT size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga4ced61bc9752b42236f79929a3daf830">drx_instrlist_app_size</a> (<a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist)</td></tr>
<tr class="separator:ga4ced61bc9752b42236f79929a3daf830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a5fcca247de11374c3555a5326cba8"><td class="memItemLeft" align="right" valign="top">DR_EXPORT file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#gaa0a5fcca247de11374c3555a5326cba8">drx_open_unique_file</a> (const char *dir, const char *prefix, const char *suffix, uint extra_flags, char *result OUT, size_t result_len)</td></tr>
<tr class="separator:gaa0a5fcca247de11374c3555a5326cba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85537dd6726928bbd43a21dc8211a53"><td class="memItemLeft" align="right" valign="top">DR_EXPORT file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#gaa85537dd6726928bbd43a21dc8211a53">drx_open_unique_appid_file</a> (const char *dir, ptr_int_t id, const char *prefix, const char *suffix, uint extra_flags, char *result OUT, size_t result_len)</td></tr>
<tr class="separator:gaa85537dd6726928bbd43a21dc8211a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdcaedde814b3ff345686c6a3abf879c"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#gafdcaedde814b3ff345686c6a3abf879c">drx_open_unique_appid_dir</a> (const char *dir, ptr_int_t id, const char *prefix, const char *suffix, char *result OUT, size_t result_len)</td></tr>
<tr class="separator:gafdcaedde814b3ff345686c6a3abf879c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4caa3e50a3cfb5ecb5c08e65fc44ada3"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga4caa3e50a3cfb5ecb5c08e65fc44ada3">drx_buf_create_circular_buffer</a> (size_t buf_size)</td></tr>
<tr class="separator:ga4caa3e50a3cfb5ecb5c08e65fc44ada3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d48f2339de13a75bfe21b5fd04a6c7"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga26d48f2339de13a75bfe21b5fd04a6c7">drx_buf_create_trace_buffer</a> (size_t buffer_size, <a class="el" href="group__drx.html#ga8006198d0e3f3f85df687e9286de597c">drx_buf_full_cb_t</a> full_cb)</td></tr>
<tr class="separator:ga26d48f2339de13a75bfe21b5fd04a6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1182ac061717e3244891e43dab2a7d23"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga1182ac061717e3244891e43dab2a7d23">drx_buf_free</a> (<a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf)</td></tr>
<tr class="separator:ga1182ac061717e3244891e43dab2a7d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f82cda96d7ee9c3236ab520f192d96"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga42f82cda96d7ee9c3236ab520f192d96">drx_buf_insert_load_buf_ptr</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> buf_ptr)</td></tr>
<tr class="separator:ga42f82cda96d7ee9c3236ab520f192d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187d0c9f694b5bbd97a509c72c3cccf6"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga187d0c9f694b5bbd97a509c72c3cccf6">drx_buf_insert_update_buf_ptr</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> buf_ptr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> scratch, ushort stride)</td></tr>
<tr class="separator:ga187d0c9f694b5bbd97a509c72c3cccf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707a2f43fd22d2203d1274a498e7cf8b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga707a2f43fd22d2203d1274a498e7cf8b">drx_buf_insert_buf_store</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> buf_ptr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> scratch, <a class="el" href="structopnd__t.html">opnd_t</a> opnd, <a class="el" href="dr__ir__opnd_8h.html#a74a13beec75b515dee3dffd3a12110ff">opnd_size_t</a> opsz, short offset)</td></tr>
<tr class="separator:ga707a2f43fd22d2203d1274a498e7cf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d46be87bc7b8ebd470609250347740f"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga6d46be87bc7b8ebd470609250347740f">drx_buf_get_buffer_ptr</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf)</td></tr>
<tr class="separator:ga6d46be87bc7b8ebd470609250347740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22218727d86b15b625a9d0f5729b9955"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga22218727d86b15b625a9d0f5729b9955">drx_buf_set_buffer_ptr</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf, void *new_ptr)</td></tr>
<tr class="separator:ga22218727d86b15b625a9d0f5729b9955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab387ef4cf4e739dba536149361d3b6c2"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#gab387ef4cf4e739dba536149361d3b6c2">drx_buf_get_buffer_base</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf)</td></tr>
<tr class="separator:gab387ef4cf4e739dba536149361d3b6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf71b198fcd63f42e35df44285ceec3"><td class="memItemLeft" align="right" valign="top">DR_EXPORT size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga2cf71b198fcd63f42e35df44285ceec3">drx_buf_get_buffer_size</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf)</td></tr>
<tr class="separator:ga2cf71b198fcd63f42e35df44285ceec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f9c7628a63632568aaeb62beeb3a89a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga8f9c7628a63632568aaeb62beeb3a89a">drx_tail_pad_block</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist)</td></tr>
<tr class="separator:ga8f9c7628a63632568aaeb62beeb3a89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71e3315ee11f3f51fd16e9488c79051"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#gad71e3315ee11f3f51fd16e9488c79051">drx_buf_insert_buf_memcpy</a> (void *drcontext, <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *buf, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> dst, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> src, ushort len)</td></tr>
<tr class="separator:gad71e3315ee11f3f51fd16e9488c79051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c372c0385d8584660f5c449a18ec36"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drx.html#ga30c372c0385d8584660f5c449a18ec36">drx_expand_scatter_gather</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, OUT bool *expanded)</td></tr>
<tr class="separator:ga30c372c0385d8584660f5c449a18ec36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6ddda40d50adc634c87223c1dd474a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ddda40d50adc634c87223c1dd474a3e">&#9670;&nbsp;</a></span>DRMGR_PRIORITY_NAME_DRX_BUF_EXIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_DRX_BUF_EXIT&#160;&#160;&#160;&quot;drx_buf.exit&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of drx_buf thread exit priority for buffer cleanup and full_cb callback. </p>

</div>
</div>
<a id="ga0645733e06c68e965ccc9e7c3126d438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0645733e06c68e965ccc9e7c3126d438">&#9670;&nbsp;</a></span>DRMGR_PRIORITY_NAME_DRX_BUF_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_DRX_BUF_INIT&#160;&#160;&#160;&quot;drx_buf.init&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of drx_buf thread init priority for buffer initialization. </p>

</div>
</div>
<a id="ga48c78ac1ff92549afbe94c26369e168e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c78ac1ff92549afbe94c26369e168e">&#9670;&nbsp;</a></span>DRMGR_PRIORITY_NAME_DRX_FAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_DRX_FAULT&#160;&#160;&#160;&quot;drx_fault&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of drx fault handling event. </p>

</div>
</div>
<a id="ga1c12b3b71826d8b412f25a0059fd2017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c12b3b71826d8b412f25a0059fd2017">&#9670;&nbsp;</a></span>DRX_FILE_SKIP_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRX_FILE_SKIP_OPEN&#160;&#160;&#160;0x8000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag for use with <a class="el" href="group__drx.html#gaa0a5fcca247de11374c3555a5326cba8">drx_open_unique_file()</a> or <a class="el" href="group__drx.html#gaa85537dd6726928bbd43a21dc8211a53">drx_open_unique_appid_file()</a> in <code>extra_flags</code> to skip the file open and get the path string only.</p>
<dl class="section note"><dt>Note</dt><dd>This flag value must not conflict with any DR_FILE_* flag value used by <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8006198d0e3f3f85df687e9286de597c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8006198d0e3f3f85df687e9286de597c">&#9670;&nbsp;</a></span>drx_buf_full_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* drx_buf_full_cb_t) (void *drcontext, void *buf_base, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for <code>drx_buf_init_trace_buffer()</code>, called when the buffer has been filled. The valid buffer data is contained within the interval [buf_base..buf_base+size). </p>

</div>
</div>
<a id="ga839a0a82cdb05bc4285369d905e3daaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga839a0a82cdb05bc4285369d905e3daaf">&#9670;&nbsp;</a></span>drx_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _drx_buf_t <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque handle which represents a buffer for use by the drx_buf framework. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0944a4353780132eeab7b06e3e42291d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0944a4353780132eeab7b06e3e42291d">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0944a4353780132eeab7b06e3e42291da8cd3adf4599b9be81a32a0d111df47ed"></a>DRMGR_PRIORITY_FAULT_DRX&#160;</td><td class="fielddoc"><p>Priority of drx fault handling event. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4caf8d8f829279fba122163d961608a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4caf8d8f829279fba122163d961608a4">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags for <code>drx_insert_counter_update</code> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4caf8d8f829279fba122163d961608a4a507636af18a8858c214066682d013a1a"></a>DRX_COUNTER_64BIT&#160;</td><td class="fielddoc"><p>64-bit counter is used for update. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4caf8d8f829279fba122163d961608a4aa50fccbd9d5dc9f300d6033c971f95e4"></a>DRX_COUNTER_REL_ACQ&#160;</td><td class="fielddoc"><p>Release-acquire semantics for counter update. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4caf8d8f829279fba122163d961608a4aa45e32a1d62398b84858de6759364688"></a>DRX_COUNTER_LOCK&#160;</td><td class="fielddoc"><p>Counter update is atomic. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga96a58e29e8dbf2b5bdeb775cba46556e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96a58e29e8dbf2b5bdeb775cba46556e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga96a58e29e8dbf2b5bdeb775cba46556ea72c2469ba268615b188959b3ffbef685"></a>DRX_BUF_FAST_CIRCULAR_BUFSZ&#160;</td><td class="fielddoc"><p>Buffer size to be specified in <a class="el" href="group__drx.html#ga4caa3e50a3cfb5ecb5c08e65fc44ada3">drx_buf_create_circular_buffer()</a> in order to make use of the fast circular buffer optimization. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab48899087cc647f0f791ed0c459adc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab48899087cc647f0f791ed0c459adc53">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priorities of drmgr instrumentation passes used by drx_buf. Users of drx_buf can use the names <a class="el" href="group__drx.html#ga0645733e06c68e965ccc9e7c3126d438">DRMGR_PRIORITY_NAME_DRX_BUF_INIT</a> and <a class="el" href="group__drx.html#ga6ddda40d50adc634c87223c1dd474a3e">DRMGR_PRIORITY_NAME_DRX_BUF_EXIT</a> in the <a class="el" href="struct__drmgr__priority__t.html#ac73be551eedc5f37043fb752b30eec32">drmgr_priority_t.before</a> field or can use these numeric priorities in the <a class="el" href="struct__drmgr__priority__t.html#a2e46fa4cbefc2dc32f3bc73e8bd82d3e">drmgr_priority_t.priority</a> field to ensure proper instrumentation pass ordering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab48899087cc647f0f791ed0c459adc53ad97fe2f57b9c6ec96fd3b8461b0cfeb1"></a>DRMGR_PRIORITY_THREAD_INIT_DRX_BUF&#160;</td><td class="fielddoc"><p>Priority of drx_buf thread init event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab48899087cc647f0f791ed0c459adc53a2c71daa1f7dc4665d5e32997578809c0"></a>DRMGR_PRIORITY_THREAD_EXIT_DRX_BUF&#160;</td><td class="fielddoc"><p>Priority of drx_buf thread exit event </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae33a91872caa46e430d5d721af6d8c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae33a91872caa46e430d5d721af6d8c82">&#9670;&nbsp;</a></span>drx_aflags_are_dead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_aflags_are_dead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analyze if arithmetic flags are dead after (including) instruction <code>where</code>.</p>
<dl class="section note"><dt>Note</dt><dd>May be called without calling <a class="el" href="group__drx.html#gae0665a86427616ffc80c59375649e283">drx_init()</a>. </dd></dl>

</div>
</div>
<a id="ga4caa3e50a3cfb5ecb5c08e65fc44ada3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4caa3e50a3cfb5ecb5c08e65fc44ada3">&#9670;&nbsp;</a></span>drx_buf_create_circular_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a>* drx_buf_create_circular_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the drx_buf extension with a circular buffer which wraps around when full.</p>
<dl class="section note"><dt>Note</dt><dd>All buffer sizes are supported. However, a buffer size of <a class="el" href="group__drx.html#gga96a58e29e8dbf2b5bdeb775cba46556ea72c2469ba268615b188959b3ffbef685">DRX_BUF_FAST_CIRCULAR_BUFSZ</a> bytes is specially optimized for performance. This buffer is referred to explicitly in the documentation as the "fast
circular buffer".</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if unsuccessful, a valid opaque struct pointer if successful. </dd></dl>

</div>
</div>
<a id="ga26d48f2339de13a75bfe21b5fd04a6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26d48f2339de13a75bfe21b5fd04a6c7">&#9670;&nbsp;</a></span>drx_buf_create_trace_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a>* drx_buf_create_trace_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga8006198d0e3f3f85df687e9286de597c">drx_buf_full_cb_t</a>&#160;</td>
          <td class="paramname"><em>full_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the drx_buf extension with a buffer; <code>full_cb</code> is called when the buffer becomes full.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if unsuccessful, a valid opaque struct pointer if successful. </dd></dl>

</div>
</div>
<a id="ga1182ac061717e3244891e43dab2a7d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1182ac061717e3244891e43dab2a7d23">&#9670;&nbsp;</a></span>drx_buf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_buf_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up the buffer associated with <code>buf</code>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gab387ef4cf4e739dba536149361d3b6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab387ef4cf4e739dba536149361d3b6c2">&#9670;&nbsp;</a></span>drx_buf_get_buffer_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drx_buf_get_buffer_base </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a pointer to the base of the buffer. </p>

</div>
</div>
<a id="ga6d46be87bc7b8ebd470609250347740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d46be87bc7b8ebd470609250347740f">&#9670;&nbsp;</a></span>drx_buf_get_buffer_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drx_buf_get_buffer_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a pointer to the top of the buffer, that is, returns the same value as would an invocation of <a class="el" href="group__drx.html#ga42f82cda96d7ee9c3236ab520f192d96">drx_buf_insert_load_buf_ptr()</a>. </p>

</div>
</div>
<a id="ga2cf71b198fcd63f42e35df44285ceec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cf71b198fcd63f42e35df44285ceec3">&#9670;&nbsp;</a></span>drx_buf_get_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT size_t drx_buf_get_buffer_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the capacity of the buffer. </p>

</div>
</div>
<a id="gad71e3315ee11f3f51fd16e9488c79051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad71e3315ee11f3f51fd16e9488c79051">&#9670;&nbsp;</a></span>drx_buf_insert_buf_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drx_buf_insert_buf_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a memcpy-like operation that is compatible with drx_buf.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__drx.html#gad71e3315ee11f3f51fd16e9488c79051">drx_buf_insert_buf_memcpy()</a> will increment the buffer pointer internally. </dd></dl>

</div>
</div>
<a id="ga707a2f43fd22d2203d1274a498e7cf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707a2f43fd22d2203d1274a498e7cf8b">&#9670;&nbsp;</a></span>drx_buf_insert_buf_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_buf_insert_buf_store </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a74a13beec75b515dee3dffd3a12110ff">opnd_size_t</a>&#160;</td>
          <td class="paramname"><em>opsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts instructions to store <code>opsz</code> bytes of <code>opnd</code> at <code>offset</code> bytes from <code>buf_ptr</code>. <code>opnd</code> must be a register or an immediate opnd of some appropriate size. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>opsz</code> must be either <code>OPSZ_1</code>, <code>OPSZ_2</code>, <code>OPSZ_4</code> or <code>OPSZ_8</code>.</dd>
<dd>
<code>scratch</code> is only necessary on ARM when storing an immediate operand.</dd>
<dd>
This method simply wraps a store that also sets an app translation. Make sure that <code>where</code> has a translation set. </dd></dl>

</div>
</div>
<a id="ga42f82cda96d7ee9c3236ab520f192d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f82cda96d7ee9c3236ab520f192d96">&#9670;&nbsp;</a></span>drx_buf_insert_load_buf_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drx_buf_insert_load_buf_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts instructions to load the address of the TLS buffer at <code>where</code> into <code>buf_ptr</code>. </p>

</div>
</div>
<a id="ga187d0c9f694b5bbd97a509c72c3cccf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga187d0c9f694b5bbd97a509c72c3cccf6">&#9670;&nbsp;</a></span>drx_buf_insert_update_buf_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drx_buf_insert_update_buf_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts instructions to increment the buffer pointer by <code>stride</code> to accommodate the writes that occurred since the last time the base pointer was loaded.</p>
<dl class="section note"><dt>Note</dt><dd><code>scratch</code> is only necessary on ARM, in the case of the fast circular buffer. On x86 scratch is completely unused. </dd></dl>

</div>
</div>
<a id="ga22218727d86b15b625a9d0f5729b9955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22218727d86b15b625a9d0f5729b9955">&#9670;&nbsp;</a></span>drx_buf_set_buffer_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drx_buf_set_buffer_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drx.html#ga839a0a82cdb05bc4285369d905e3daaf">drx_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>new_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows one to set the buffer pointer so that subsequent invocations of <a class="el" href="group__drx.html#ga42f82cda96d7ee9c3236ab520f192d96">drx_buf_insert_load_buf_ptr()</a> will use this new value instead. </p>

</div>
</div>
<a id="ga996c662c089046984b64a627500748f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996c662c089046984b64a627500748f5">&#9670;&nbsp;</a></span>drx_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drx_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up the drx extension. </p>

</div>
</div>
<a id="ga30c372c0385d8584660f5c449a18ec36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30c372c0385d8584660f5c449a18ec36">&#9670;&nbsp;</a></span>drx_expand_scatter_gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_expand_scatter_gather </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>expanded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expands AVX2 gather and AVX-512 gather and scatter instructions to a sequence of equivalent scalar load and stores, mask register bit tests, and mask register bit updates.</p>
<p>Clients applying this expansion are encouraged to use emulation-aware instrumentation via <a class="el" href="group__drmgr.html#gad375fb1c1a8683c54a78f4f5b9951f4a">drmgr_orig_app_instr_for_fetch()</a> and <a class="el" href="group__drmgr.html#ga6373ac13132abb039c7d0593bde073ba">drmgr_orig_app_instr_for_operands()</a> in order to observe the original opcode with the expanded memory operands.</p>
<dl class="section warning"><dt>Warning</dt><dd>The added multi-instruction sequence contains several control-transfer instructions and is not straight-line code, which can complicate subsequent analysis routines.</dd></dl>
<p>The client must use the <code>drmgr</code> Extension to order its instrumentation in order to use this function. This function must be called from the application-to-application ("app2app") stage (see <a class="el" href="group__drmgr.html#gae270eeb1ab24d4e05f8588b23822f45c">drmgr_register_bb_app2app_event()</a>).</p>
<p>This transformation is deterministic, so the caller can return DR_EMIT_DEFAULT from its event.</p>
<p>The *dq, *qd, *qq, *dpd, *qps, and *qpd opcodes are not yet supported in 32-bit mode. In this case, the function will return false and no expansion will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The opaque context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bb</td><td>Instruction list passed to the app2app event. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">expanded</td><td>Whether any expansion occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gae0665a86427616ffc80c59375649e283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0665a86427616ffc80c59375649e283">&#9670;&nbsp;</a></span>drx_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the drx extension. Must be called prior to any drx routine that does not explicitly state otherwise. Can be called multiple times (by separate components, normally) but each call must be paired with a corresponding call to <a class="el" href="group__drx.html#ga996c662c089046984b64a627500748f5">drx_exit()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga5eba10b0f9536c1a108d796e0b84c4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eba10b0f9536c1a108d796e0b84c4cd">&#9670;&nbsp;</a></span>drx_insert_counter_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_insert_counter_update </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IF_NOT_X86_(<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot2) void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to add the constant <code>value</code> to the counter located at <code>addr</code>. Different DRX_COUNTER_* options can be specified by <code>flags</code>.</p>
<p>When used with drmgr, this routine uses the drreg extension. It must be called from drmgr's insertion phase. The drreg extension will be used to spill the arithmetic flags and any scratch registers needed. It is up to the caller to ensure that enough spill slots are available, through drreg's initialization. The slot and slot2 parameters must be set to SPILL_SLOT_MAX+1.</p>
<p>When used without drmgr, the spill slot <code>slot</code> is used for storing arithmetic flags or a scratch register if necessary. The spill slot <code>slot2</code> is used only on ARM for spilling a second scratch register.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The counter update is racy (i.e., not synchronized among threads) unless <a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4aa45e32a1d62398b84858de6759364688">DRX_COUNTER_LOCK</a> is specified in <code>flags</code>. When <a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4aa45e32a1d62398b84858de6759364688">DRX_COUNTER_LOCK</a> is set, the instrumentation may fail if a 64-bit counter is updated in a 32-bit application or the counter crosses cache lines. Currently, <a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4aa45e32a1d62398b84858de6759364688">DRX_COUNTER_LOCK</a> is not yet supported on AArchXX. For AArchXX, if <a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4aa50fccbd9d5dc9f300d6033c971f95e4">DRX_COUNTER_REL_ACQ</a> is specified in <code>flags</code>, release-acquire semantics are enforced for the counter update. The <a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4aa50fccbd9d5dc9f300d6033c971f95e4">DRX_COUNTER_REL_ACQ</a> flag can be used in conjunction with <a class="el" href="group__drx.html#gga4caf8d8f829279fba122163d961608a4a507636af18a8858c214066682d013a1a">DRX_COUNTER_64BIT</a>.</dd>
<dd>
To update multiple counters at the same place, multiple <a class="el" href="group__drx.html#ga5eba10b0f9536c1a108d796e0b84c4cd">drx_insert_counter_update()</a> invocations should be made in a row with the same <code>where</code> instruction and no other instructions should be inserted in between. In that case, <code>drx</code> will try to merge the instrumentation for better performance. </dd></dl>

</div>
</div>
<a id="ga4ced61bc9752b42236f79929a3daf830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ced61bc9752b42236f79929a3daf830">&#9670;&nbsp;</a></span>drx_instrlist_app_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT size_t drx_instrlist_app_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of application instructions (excluding meta-instructions) inside a basic block <code>ilist</code>.</p>
<p>The function iterates over the ilist in order to obtain the count. The result is not cached. Therefore, avoid using this function during the insert stage of the instrumentation process. </p>

</div>
</div>
<a id="ga2f2b2e6468760cdee7c55975e8cdce5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f2b2e6468760cdee7c55975e8cdce5c">&#9670;&nbsp;</a></span>drx_instrlist_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT size_t drx_instrlist_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of instructions (including meta-instructions) inside a basic block <code>ilist</code>.</p>
<p>The function iterates over the ilist in order to obtain the count. The result is not cached. Therefore, avoid using this function during the insert stage of the instrumentation process. </p>

</div>
</div>
<a id="gafdcaedde814b3ff345686c6a3abf879c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdcaedde814b3ff345686c6a3abf879c">&#9670;&nbsp;</a></span>drx_open_unique_appid_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_open_unique_appid_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_int_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *result&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new directory with a name constructed from "dir/prefix.appname.id.xxxx.suffix", where xxxx is a 4-digit number incremented until a unique name is found that does not collide with any existing file. The appname string comes from <a class="el" href="dr__os__utils_8h.html#aef60db347b52f1344c23b63bcb020ff6">dr_get_application_name()</a>. The id portion of the string is from <code>id</code>, which is meant to be either the process id or the thread id.</p>
<p>Returns whether successful. On success, optionally returns the resulting path in <code>result</code>.</p>
<dl class="section note"><dt>Note</dt><dd>May be called without calling <a class="el" href="group__drx.html#gae0665a86427616ffc80c59375649e283">drx_init()</a>. </dd></dl>

</div>
</div>
<a id="gaa85537dd6726928bbd43a21dc8211a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85537dd6726928bbd43a21dc8211a53">&#9670;&nbsp;</a></span>drx_open_unique_appid_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT file_t drx_open_unique_appid_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_int_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>extra_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *result&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a new file with a name constructed from "dir/prefix.appname.id.xxxx.suffix", where xxxx is a 4-digit number incremented until a unique name is found that does not collide with any existing file. The appname string comes from <a class="el" href="dr__os__utils_8h.html#aef60db347b52f1344c23b63bcb020ff6">dr_get_application_name()</a>. The id portion of the string is from <code>id</code>, which is meant to be either the process id or the thread id.</p>
<p>Passes <code>extra_flags</code> through to the <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a> call if <code>extra_flags</code> is not DRX_FILE_SKIP_OPEN.</p>
<p>On success, returns the file handle and optionally the resulting path in <code>result</code>. On failure, returns INVALID_FILE.</p>
<p>Skips <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a> if <code>extra_flags</code> is DRX_FILE_SKIP_OPEN. Returns INVALID_FILE and optionally the resulting path in <code>result</code>. Unique name is not guaranteed and xxxx is set randomly.</p>
<dl class="section note"><dt>Note</dt><dd>May be called without calling <a class="el" href="group__drx.html#gae0665a86427616ffc80c59375649e283">drx_init()</a>. </dd></dl>

</div>
</div>
<a id="gaa0a5fcca247de11374c3555a5326cba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a5fcca247de11374c3555a5326cba8">&#9670;&nbsp;</a></span>drx_open_unique_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT file_t drx_open_unique_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>extra_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *result&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a new file with a name constructed from "dir/prefix.xxxx.suffix", where xxxx is a 4-digit number incremented until a unique name is found that does not collide with any existing file.</p>
<p>Passes <code>extra_flags</code> through to the <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a> call if <code>extra_flags</code> is not DRX_FILE_SKIP_OPEN.</p>
<p>On success, returns the file handle and optionally the resulting path in <code>result</code>. On failure, returns INVALID_FILE.</p>
<p>Skips <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a> if <code>extra_flags</code> is DRX_FILE_SKIP_OPEN. Returns INVALID_FILE and optionally the resulting path in <code>result</code>. Unique name is not guaranteed and xxxx is set randomly.</p>
<dl class="section note"><dt>Note</dt><dd>May be called without calling <a class="el" href="group__drx.html#gae0665a86427616ffc80c59375649e283">drx_init()</a>. </dd></dl>

</div>
</div>
<a id="ga9348e840424caf0098a8b1ba69955864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9348e840424caf0098a8b1ba69955864">&#9670;&nbsp;</a></span>drx_register_soft_kills()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_register_soft_kills </td>
          <td>(</td>
          <td class="paramtype">bool(*)(process_id_t pid, int exit_code)&#160;</td>
          <td class="paramname"><em>event_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers for the "soft kills" event, which helps to execute process exit events when a process is terminated by another process.</p>
<p>The callback's return value indicates whether to skip the termination action by the application: i.e., true indicates to skip it (the usual case) and false indicates to continue with the application action. In some cases, individually continuing requires emulation when the original application action involved multiple processes.</p>
<p>When there are multiple registered callbacks, if any callback returns true, the application action is skipped.</p>
<p>In normal usage, upon receiving this callback the client will send a nudge (see <a class="el" href="dr__events_8h.html#a9e0a6ebc74a4aa8efaed1d6b737512d2">dr_nudge_client_ex()</a>) to the targeted process. The nudge handler then performs any shutdown actions, such as instrumentation result output. The handler then terminates the target process from within, allowing the callback in the targeting process to skip the termination action. Passing the exit code to the nudge handler is recommended to preserve the intended application exit code.</p>
<p>The nudge handler should support being invoked multiple times (typically by having only the first one take effect) as in some cases a parent process will terminate child processes in multiple ways.</p>
<p>This event must be registered for during process initialization, in order to properly track per-thread information. Un-registering is not supported: soft kills cannot be in effect for only part of the process lifetime.</p>
<p>Soft kills can be risky. If the targeted process is not under DynamoRIO control, the nudge might terminate it, but in a different manner than would have occurred. If the nudge fails for some reason but the targeter's termination is still skipped, the child process might be left alive, causing the application to behave incorrectly.</p>
<p>The implementation of this event uses drmgr's CLS (<a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>), which conflicts with <a class="el" href="dr__tools_8h.html#aaa04a14c2cbf783b4926c2fd14445f82">dr_get_tls_field()</a>. A client using this event must use <a class="el" href="group__drmgr.html#ga512b4290d94b1874537e5b604cb27cab">drmgr_register_tls_field()</a> instead of <a class="el" href="dr__tools_8h.html#aaa04a14c2cbf783b4926c2fd14445f82">dr_get_tls_field()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga3189cbfbf85d5c32965bd8a140b2c35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3189cbfbf85d5c32965bd8a140b2c35e">&#9670;&nbsp;</a></span>drx_reserve_note_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT ptr_uint_t drx_reserve_note_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves <code>size</code> values in the namespace for use in the <code>note</code> field of instructions. The reserved range starts at the return value and is contiguous. Returns DRX_NOTE_NONE on failure. Un-reserving is not supported. </p>

</div>
</div>
<a id="ga8f9c7628a63632568aaeb62beeb3a89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f9c7628a63632568aaeb62beeb3a89a">&#9670;&nbsp;</a></span>drx_tail_pad_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drx_tail_pad_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pads a basic block with a label at the end for routines which rely on inserting instrumentation after every instruction. Note that users of this routine must act on the previous instruction in basic block events before skipping non-app instructions because the label is not marked as an app instruction.</p>
<dl class="section note"><dt>Note</dt><dd>the padding label is not introduced if the basic block is already branch terminated.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether padding was introduced. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
