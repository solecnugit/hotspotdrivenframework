---
title: "Register Usage Coordinator"
layout: default
permalink: /group__drreg.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Register Usage Coordinator</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drreg__options__t.html">_drreg_options_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drreg__reserve__info__t.html">_drreg_reserve_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga28a24e0698d1cb440408ac7822599b56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga28a24e0698d1cb440408ac7822599b56">DRMGR_PRIORITY_NAME_DRREG_HIGH</a>&#160;&#160;&#160;&quot;drreg_high&quot;</td></tr>
<tr class="separator:ga28a24e0698d1cb440408ac7822599b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029fce197e2cdd4f155a4949ea25224b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga029fce197e2cdd4f155a4949ea25224b">DRMGR_PRIORITY_NAME_DRREG_LOW</a>&#160;&#160;&#160;&quot;drreg_low&quot;</td></tr>
<tr class="separator:ga029fce197e2cdd4f155a4949ea25224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1269daa77244cc3b6a3a10cc2bbd986c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga1269daa77244cc3b6a3a10cc2bbd986c">DRMGR_PRIORITY_NAME_DRREG_FAULT</a>&#160;&#160;&#160;&quot;drreg_fault&quot;</td></tr>
<tr class="separator:ga1269daa77244cc3b6a3a10cc2bbd986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0aaceb18f0b53676faca34a2d43746f7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drreg__options__t.html">_drreg_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga0aaceb18f0b53676faca34a2d43746f7">drreg_options_t</a></td></tr>
<tr class="separator:ga0aaceb18f0b53676faca34a2d43746f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a91ecc67def444d5922a58fe0f641e4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drreg__reserve__info__t.html">_drreg_reserve_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga1a91ecc67def444d5922a58fe0f641e4">drreg_reserve_info_t</a></td></tr>
<tr class="separator:ga1a91ecc67def444d5922a58fe0f641e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad5b7a7a020d7206b11e61e7cdae02ee9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> { <br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9ab62388bb72ad127e07c1ffafb213cb6e">DRREG_SUCCESS</a>, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a92467b9ab217a666f25ed5187c8a62ba">DRREG_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a6469f0a30bc576af0fc10f34b1c2f5f0">DRREG_ERROR_INVALID_PARAMETER</a>, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a2e5bfa6fd0ae9eacd41f069055f0a9d3">DRREG_ERROR_FEATURE_NOT_AVAILABLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a7a9225ed7b430d71a91ae479aa46691e">DRREG_ERROR_REG_CONFLICT</a>, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a1ec4af3d84c577d10ef4bbfc8050f31c">DRREG_ERROR_IN_USE</a>, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9aeed6748debd71284e27eb683b4dc2e2d">DRREG_ERROR_OUT_OF_SLOTS</a>, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a1f21cc5ebb7031b6430b3cdb2a21ddf8">DRREG_ERROR_NO_APP_VALUE</a>
<br />
 }</td></tr>
<tr class="separator:gad5b7a7a020d7206b11e61e7cdae02ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabfcbcb5ac86a1edac4035264bc7d2b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__drreg.html#ggaabfcbcb5ac86a1edac4035264bc7d2b8a6ec36608f877bb98ba1d9d0cd0941b6a">DRMGR_PRIORITY_INSERT_DRREG_HIGH</a> = -7500, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggaabfcbcb5ac86a1edac4035264bc7d2b8a4681b1eae66fea088d2437640a837caf">DRMGR_PRIORITY_INSERT_DRREG_LOW</a> = 7500, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#ggaabfcbcb5ac86a1edac4035264bc7d2b8a1e68a52ce0fc6755b47fe317d9e7afc8">DRMGR_PRIORITY_FAULT_DRREG</a> = -7500
<br />
 }</td></tr>
<tr class="separator:gaabfcbcb5ac86a1edac4035264bc7d2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa35aebc3d4f0f41cba66bfcde82a00"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga9aa35aebc3d4f0f41cba66bfcde82a00">drreg_bb_properties_t</a> { <br />
&#160;&#160;<a class="el" href="group__drreg.html#gga9aa35aebc3d4f0f41cba66bfcde82a00a7480b21f4a67dd853d857271f4eaf058">DRREG_CONTAINS_SPANNING_CONTROL_FLOW</a> = 0x001, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#gga9aa35aebc3d4f0f41cba66bfcde82a00a7bbb7c0168068bd904f612b89b4c5dc9">DRREG_IGNORE_CONTROL_FLOW</a> = 0x002, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#gga9aa35aebc3d4f0f41cba66bfcde82a00a2d5f9cc167553f4145dc5adb8eac3f9d">DRREG_USER_RESTORES_AT_BB_END</a> = 0x004, 
<br />
&#160;&#160;<a class="el" href="group__drreg.html#gga9aa35aebc3d4f0f41cba66bfcde82a00a2d1537112f577f6e8943463069b523d6">DRREG_HANDLE_MULTI_PHASE_SLOT_RESERVATIONS</a> = 0x008
<br />
 }</td></tr>
<tr class="separator:ga9aa35aebc3d4f0f41cba66bfcde82a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6656df86f1a73bdf739eedaba7220c46"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga6656df86f1a73bdf739eedaba7220c46">drreg_init</a> (<a class="el" href="group__drreg.html#ga0aaceb18f0b53676faca34a2d43746f7">drreg_options_t</a> *ops)</td></tr>
<tr class="separator:ga6656df86f1a73bdf739eedaba7220c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac43a098af5baddf9190a332550d50f85"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gac43a098af5baddf9190a332550d50f85">drreg_exit</a> (void)</td></tr>
<tr class="separator:gac43a098af5baddf9190a332550d50f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee93e052a9f400de45b822aff0a6db1"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gaaee93e052a9f400de45b822aff0a6db1">drreg_max_slots_used</a> (OUT uint *max)</td></tr>
<tr class="separator:gaaee93e052a9f400de45b822aff0a6db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dafaf790ed3811076311d57b037a800"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga5dafaf790ed3811076311d57b037a800">drreg_reserve_aflags</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:ga5dafaf790ed3811076311d57b037a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e6f06ca372fef0437652ba8915fc09d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga5e6f06ca372fef0437652ba8915fc09d">drreg_unreserve_aflags</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:ga5e6f06ca372fef0437652ba8915fc09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc912c459f23dfd8455718c2a958749"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gabdc912c459f23dfd8455718c2a958749">drreg_aflags_liveness</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *inst, OUT uint *value)</td></tr>
<tr class="separator:gabdc912c459f23dfd8455718c2a958749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bbee2cddb1024c65de2f70288b79c9d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga2bbee2cddb1024c65de2f70288b79c9d">drreg_are_aflags_dead</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool *dead)</td></tr>
<tr class="separator:ga2bbee2cddb1024c65de2f70288b79c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ba110d4aca864533583a53f8e04d40"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gae2ba110d4aca864533583a53f8e04d40">drreg_restore_app_aflags</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:gae2ba110d4aca864533583a53f8e04d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab922bcd0f9216884db35f2e6423f6337"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gab922bcd0f9216884db35f2e6423f6337">drreg_reserve_register</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *reg_allowed, OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *reg)</td></tr>
<tr class="separator:gab922bcd0f9216884db35f2e6423f6337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83416a76d3e020f4c7f86036dbe98824"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga83416a76d3e020f4c7f86036dbe98824">drreg_reserve_dead_register</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *reg_allowed, OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *reg)</td></tr>
<tr class="separator:ga83416a76d3e020f4c7f86036dbe98824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d81ea8114d9aea29b340dd034cda04"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gad5d81ea8114d9aea29b340dd034cda04">drreg_init_and_fill_vector</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec, bool allowed)</td></tr>
<tr class="separator:gad5d81ea8114d9aea29b340dd034cda04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2878afd0bb1dcc73ebf1eb99a83748ce"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga2878afd0bb1dcc73ebf1eb99a83748ce">drreg_set_vector_entry</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, bool allowed)</td></tr>
<tr class="separator:ga2878afd0bb1dcc73ebf1eb99a83748ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ef72f8179e3a1eff9f74cab9d733c4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga52ef72f8179e3a1eff9f74cab9d733c4">drreg_get_app_value</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> app_reg, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> dst_reg)</td></tr>
<tr class="separator:ga52ef72f8179e3a1eff9f74cab9d733c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a0543b8c49f5bb7af6cae384af34d2"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gaf3a0543b8c49f5bb7af6cae384af34d2">drreg_restore_app_values</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structopnd__t.html">opnd_t</a> opnd, INOUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *swap)</td></tr>
<tr class="separator:gaf3a0543b8c49f5bb7af6cae384af34d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7fbf107e7b10fffb8da7d93b74153c4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gad7fbf107e7b10fffb8da7d93b74153c4">drreg_restore_all</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:gad7fbf107e7b10fffb8da7d93b74153c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd4dc9f52ffd96616ee1eb92ebd5a9c"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga4dd4dc9f52ffd96616ee1eb92ebd5a9c">drreg_statelessly_restore_app_value</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="structinstr__t.html">instr_t</a> *where_restore, <a class="el" href="structinstr__t.html">instr_t</a> *where_respill, bool *restore_needed OUT, bool *respill_needed OUT)</td></tr>
<tr class="separator:ga4dd4dc9f52ffd96616ee1eb92ebd5a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca98376d910bf8b417d60954193cae1"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga2ca98376d910bf8b417d60954193cae1">drreg_statelessly_restore_all</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where_restore, <a class="el" href="structinstr__t.html">instr_t</a> *where_respill, bool *restore_needed OUT, bool *respill_needed OUT)</td></tr>
<tr class="separator:ga2ca98376d910bf8b417d60954193cae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a587dee2fc48409d6486ab5fd91e74"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga39a587dee2fc48409d6486ab5fd91e74">drreg_reservation_info</a> (void *drcontext, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="structopnd__t.html">opnd_t</a> *opnd OUT, bool *is_dr_slot OUT, uint *tls_offs OUT)</td></tr>
<tr class="separator:ga39a587dee2fc48409d6486ab5fd91e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ff9a156f64e7146284385f2a26c8e4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gad8ff9a156f64e7146284385f2a26c8e4">drreg_reservation_info_ex</a> (void *drcontext, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="group__drreg.html#ga1a91ecc67def444d5922a58fe0f641e4">drreg_reserve_info_t</a> *info OUT)</td></tr>
<tr class="separator:gad8ff9a156f64e7146284385f2a26c8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3226af61d5322e93c97546e49d79d983"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga3226af61d5322e93c97546e49d79d983">drreg_unreserve_register</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:ga3226af61d5322e93c97546e49d79d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7e85dfc7999a76432096613383d4e4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#gadc7e85dfc7999a76432096613383d4e4">drreg_is_register_dead</a> (void *drcontext, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool *dead)</td></tr>
<tr class="separator:gadc7e85dfc7999a76432096613383d4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7910ab166b0d698c11964a7b89d90faf"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga7910ab166b0d698c11964a7b89d90faf">drreg_set_bb_properties</a> (void *drcontext, <a class="el" href="group__drreg.html#ga9aa35aebc3d4f0f41cba66bfcde82a00">drreg_bb_properties_t</a> flags)</td></tr>
<tr class="separator:ga7910ab166b0d698c11964a7b89d90faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bec0cc14f3254a088c7c4dd3d76931e"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drreg.html#ga0bec0cc14f3254a088c7c4dd3d76931e">drreg_is_instr_spill_or_restore</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, bool *spill OUT, bool *restore OUT, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *reg_spilled OUT)</td></tr>
<tr class="separator:ga0bec0cc14f3254a088c7c4dd3d76931e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1269daa77244cc3b6a3a10cc2bbd986c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1269daa77244cc3b6a3a10cc2bbd986c">&#9670;&nbsp;</a></span>DRMGR_PRIORITY_NAME_DRREG_FAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_DRREG_FAULT&#160;&#160;&#160;&quot;drreg_fault&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of drreg fault handling event. </p>

</div>
</div>
<a id="ga28a24e0698d1cb440408ac7822599b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28a24e0698d1cb440408ac7822599b56">&#9670;&nbsp;</a></span>DRMGR_PRIORITY_NAME_DRREG_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_DRREG_HIGH&#160;&#160;&#160;&quot;drreg_high&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of drreg instrumentation pass priorities for analysis and insert steps that are meant to take place before any tool actions. </p>

</div>
</div>
<a id="ga029fce197e2cdd4f155a4949ea25224b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029fce197e2cdd4f155a4949ea25224b">&#9670;&nbsp;</a></span>DRMGR_PRIORITY_NAME_DRREG_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_DRREG_LOW&#160;&#160;&#160;&quot;drreg_low&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of drreg instrumentation pass priorities for analysis and insert steps that are meant to take place after any tool actions. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0aaceb18f0b53676faca34a2d43746f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aaceb18f0b53676faca34a2d43746f7">&#9670;&nbsp;</a></span>drreg_options_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drreg__options__t.html">_drreg_options_t</a> <a class="el" href="group__drreg.html#ga0aaceb18f0b53676faca34a2d43746f7">drreg_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the options when initializing drreg. </p>

</div>
</div>
<a id="ga1a91ecc67def444d5922a58fe0f641e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a91ecc67def444d5922a58fe0f641e4">&#9670;&nbsp;</a></span>drreg_reserve_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drreg__reserve__info__t.html">_drreg_reserve_info_t</a> <a class="el" href="group__drreg.html#ga1a91ecc67def444d5922a58fe0f641e4">drreg_reserve_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contains information about a register's reservation and restoration status. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaabfcbcb5ac86a1edac4035264bc7d2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabfcbcb5ac86a1edac4035264bc7d2b8">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priorities of drmgr instrumentation passes used by drreg. Users of drreg can use the name DRMGR_PRIORITY_NAME_DRREG in the <a class="el" href="struct__drmgr__priority__t.html#ac73be551eedc5f37043fb752b30eec32">drmgr_priority_t.before</a> field or can use these numeric priorities in the <a class="el" href="struct__drmgr__priority__t.html#a2e46fa4cbefc2dc32f3bc73e8bd82d3e">drmgr_priority_t.priority</a> field to ensure proper instrumentation pass ordering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaabfcbcb5ac86a1edac4035264bc7d2b8a6ec36608f877bb98ba1d9d0cd0941b6a"></a>DRMGR_PRIORITY_INSERT_DRREG_HIGH&#160;</td><td class="fielddoc"><p>Priority of drreg analysis and pre-insert </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabfcbcb5ac86a1edac4035264bc7d2b8a4681b1eae66fea088d2437640a837caf"></a>DRMGR_PRIORITY_INSERT_DRREG_LOW&#160;</td><td class="fielddoc"><p>Priority of drreg post-insert </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabfcbcb5ac86a1edac4035264bc7d2b8a1e68a52ce0fc6755b47fe317d9e7afc8"></a>DRMGR_PRIORITY_FAULT_DRREG&#160;</td><td class="fielddoc"><p>Priority of drreg fault handling event </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9aa35aebc3d4f0f41cba66bfcde82a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aa35aebc3d4f0f41cba66bfcde82a00">&#9670;&nbsp;</a></span>drreg_bb_properties_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drreg.html#ga9aa35aebc3d4f0f41cba66bfcde82a00">drreg_bb_properties_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags passed to <a class="el" href="group__drreg.html#ga7910ab166b0d698c11964a7b89d90faf">drreg_set_bb_properties()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9aa35aebc3d4f0f41cba66bfcde82a00a7480b21f4a67dd853d857271f4eaf058"></a>DRREG_CONTAINS_SPANNING_CONTROL_FLOW&#160;</td><td class="fielddoc"><p>drreg was designed for linear control flow and assumes that it can safely wait to restore an unreserved scratch register across application instructions. If a client inserts internal control flow that crosses application instructions (hence "spanning"), and the client is not explicitly ensuring that each forward jump contains the same set of saved scratch registers at its source and target (typically done by saving all scratch registers needed inside control flow prior to any forward branches), the client should set this property either prior to the drmgr insertion phase or as early as possible in the insertion phase. Setting this property causes application instructions to become barriers to spilled scratch registers that have been unreserved but have not yet been lazily restored. drreg will still collapse adjacent spill+restore pairs for the same app instr. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa35aebc3d4f0f41cba66bfcde82a00a7bbb7c0168068bd904f612b89b4c5dc9"></a>DRREG_IGNORE_CONTROL_FLOW&#160;</td><td class="fielddoc"><p>drreg was designed for linear control flow. Normally, drreg disables optimizations if it sees any kind of internal control flow (viz., a branch with an <a class="el" href="structinstr__t.html">instr_t</a> target) that was added during drmgr's app2app phase, which includes flow added by <a class="el" href="group__drutil.html#gae38961d42fc285d7f9034c4b02690cae">drutil_expand_rep_string()</a>. The primary consequence of disabling optimizations means that application instructions become barriers to spilled scratch registers that have been unreserved but have not yet been lazily restored, which are restored prior to each application instruction. If this flag is set, drreg assumes that internal control flow either does not cross application instructions or that the client is ensuring that each forward jump contains the same set of saved scratch registers at its source and target (typically done by saving all scratch registers needed inside control flow prior to any forward branches). Such scratch registers are then restored prior to each application instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa35aebc3d4f0f41cba66bfcde82a00a2d5f9cc167553f4145dc5adb8eac3f9d"></a>DRREG_USER_RESTORES_AT_BB_END&#160;</td><td class="fielddoc"><p>Turns off register restoration at the end of the block. Note that it is still required that registers have their original values at the end of a basic block. Therefore, restoration needs to be handled by the user manually, usually via <a class="el" href="group__drreg.html#gad7fbf107e7b10fffb8da7d93b74153c4">drreg_restore_all()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa35aebc3d4f0f41cba66bfcde82a00a2d1537112f577f6e8943463069b523d6"></a>DRREG_HANDLE_MULTI_PHASE_SLOT_RESERVATIONS&#160;</td><td class="fielddoc"><p>Turns on stricter logic to find free register spill slots. This avoids conflicts with slots used to spill some register value in prior instrumentation passes. An example usage is in <a class="el" href="group__drx.html#ga30c372c0385d8584660f5c449a18ec36">drx_expand_scatter_gather()</a> which is used in the app2app pass and requires spilling of registers to slots that may conflict with slots used during later instrumentation passes. Using this option also makes spill slots used in prior phases less available in future phases; the current logic skips over a slot if there's a usage found anywhere later in the bb added by any previous phase. So it requires additional spill slots as well. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad5b7a7a020d7206b11e61e7cdae02ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7a7a020d7206b11e61e7cdae02ee9">&#9670;&nbsp;</a></span>drreg_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Success code for each drreg operation </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9ab62388bb72ad127e07c1ffafb213cb6e"></a>DRREG_SUCCESS&#160;</td><td class="fielddoc"><p>Operation succeeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9a92467b9ab217a666f25ed5187c8a62ba"></a>DRREG_ERROR&#160;</td><td class="fielddoc"><p>Operation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9a6469f0a30bc576af0fc10f34b1c2f5f0"></a>DRREG_ERROR_INVALID_PARAMETER&#160;</td><td class="fielddoc"><p>Operation failed: invalid parameter </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9a2e5bfa6fd0ae9eacd41f069055f0a9d3"></a>DRREG_ERROR_FEATURE_NOT_AVAILABLE&#160;</td><td class="fielddoc"><p>Operation failed: not available </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9a7a9225ed7b430d71a91ae479aa46691e"></a>DRREG_ERROR_REG_CONFLICT&#160;</td><td class="fielddoc"><p>Operation failed: register conflict </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9a1ec4af3d84c577d10ef4bbfc8050f31c"></a>DRREG_ERROR_IN_USE&#160;</td><td class="fielddoc"><p>Operation failed: resource already in use </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9aeed6748debd71284e27eb683b4dc2e2d"></a>DRREG_ERROR_OUT_OF_SLOTS&#160;</td><td class="fielddoc"><p>Operation failed: no more TLS slots </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5b7a7a020d7206b11e61e7cdae02ee9a1f21cc5ebb7031b6430b3cdb2a21ddf8"></a>DRREG_ERROR_NO_APP_VALUE&#160;</td><td class="fielddoc"><p>Operation failed: app value not available. Set <code>conservative</code> in <code>drreg_options_t</code> to avoid this error. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabdc912c459f23dfd8455718c2a958749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc912c459f23dfd8455718c2a958749">&#9670;&nbsp;</a></span>drreg_aflags_liveness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_aflags_liveness </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns in <code>value</code> EFLAGS_READ_6 bits telling which arithmetic flags are live at the point of <code>inst</code>. If called during drmgr's insertion phase, <code>inst</code> must be the current application instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga2bbee2cddb1024c65de2f70288b79c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bbee2cddb1024c65de2f70288b79c9d">&#9670;&nbsp;</a></span>drreg_are_aflags_dead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_are_aflags_dead </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>dead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns in <code>dead</code> whether the arithmetic flags are all dead at the point of <code>inst</code>. If called during drmgr's insertion phase, <code>inst</code> must be the current application instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gac43a098af5baddf9190a332550d50f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac43a098af5baddf9190a332550d50f85">&#9670;&nbsp;</a></span>drreg_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up the drreg extension. </p><dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga52ef72f8179e3a1eff9f74cab9d733c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ef72f8179e3a1eff9f74cab9d733c4">&#9670;&nbsp;</a></span>drreg_get_app_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_get_app_value </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>app_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>dst_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts instructions at <code>where</code> in <code>ilist</code> to retrieve the application value for <code>app_reg</code> into <code>dst_reg</code>. This will automatically be done for reserved registers prior to an application instruction that reads <code>app_reg</code>, but sometimes instrumentation needs to read the application value of a register that has been reserved. If <code>app_reg</code> is a dead register, <a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a1f21cc5ebb7031b6430b3cdb2a21ddf8">DRREG_ERROR_NO_APP_VALUE</a> may be returned. Set <code>conservative</code> in <code>drreg_options_t</code> to avoid this error.</p>
<p>If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<p>On ARM, asking to place the application value of the register returned by <a class="el" href="dr__ir__utils_8h.html#ad7af9296c9f5930b025186aea0688b13">dr_get_stolen_reg()</a> into itself is not supported. Instead the caller should use <a class="el" href="dr__ir__utils_8h.html#a7a38641e89e2573d725ec05d137e0fb6">dr_insert_get_stolen_reg_value()</a> and <a class="el" href="dr__ir__opnd_8h.html#aa05a718c4e4bd8e686843b9047e34612">opnd_replace_reg()</a> to swap the use of the stolen register within a tool instruction with a scratch register.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga6656df86f1a73bdf739eedaba7220c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6656df86f1a73bdf739eedaba7220c46">&#9670;&nbsp;</a></span>drreg_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drreg.html#ga0aaceb18f0b53676faca34a2d43746f7">drreg_options_t</a> *&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the drreg extension. Must be called prior to any of the other routines. Can be called multiple times (by separate components, normally) but each call must be paired with a corresponding call to <a class="el" href="group__drreg.html#gac43a098af5baddf9190a332550d50f85">drreg_exit()</a>. The fields of <code>ops</code> are combined from multiple calls as described in the documentation for each field. Typically the end-user tool itself specifies these options, with most other library components not directly interacting with drreg (libraries often take in scratch registers from the caller for most of their operations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ops</td><td>Specifies the optional parameters that control how drreg operates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gad5d81ea8114d9aea29b340dd034cda04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5d81ea8114d9aea29b340dd034cda04">&#9670;&nbsp;</a></span>drreg_init_and_fill_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_init_and_fill_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes <code>vec</code> to hold <a class="el" href="dr__ir__opnd_8h.html#ae10c1a6754e09eb003e0b651507462fe">DR_NUM_GPR_REGS</a> entries, each either set to NULL if <code>allowed</code> is false or a non-NULL value if <code>allowed</code> is true. This is intendend as a convenience routine for setting up the <code>reg_allowed</code> parameter to <a class="el" href="group__drreg.html#gab922bcd0f9216884db35f2e6423f6337">drreg_reserve_register()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga0bec0cc14f3254a088c7c4dd3d76931e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bec0cc14f3254a088c7c4dd3d76931e">&#9670;&nbsp;</a></span>drreg_is_instr_spill_or_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_is_instr_spill_or_restore </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *spill&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *restore&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *reg_spilled&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analyzes <code>instr</code> and returns whether it is a drreg register spill in <code>spill</code>, a drreg register restore in <code>restore</code>, and which register is being spilled or restored in <code>reg_spilled</code>. Each output parameter is optional and may be NULL. If DR's spill slots are being used (see <a class="el" href="struct__drreg__options__t.html#a6bbbd6b9f361d671cec4c6bd0142259d">drreg_options_t.num_spill_slots</a>), this routine may not be able to distinguish a drreg spill or restore from some other spill or restore.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gadc7e85dfc7999a76432096613383d4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc7e85dfc7999a76432096613383d4e4">&#9670;&nbsp;</a></span>drreg_is_register_dead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_is_register_dead </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>dead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns in <code>dead</code> whether the register <code>reg</code> is dead at the point of <code>inst</code>. If called during drmgr's insertion phase, <code>inst</code> must be the current application instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gaaee93e052a9f400de45b822aff0a6db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee93e052a9f400de45b822aff0a6db1">&#9670;&nbsp;</a></span>drreg_max_slots_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_max_slots_used </td>
          <td>(</td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In debug build, drreg tracks the maximum simultaneous number of spill slots in use. This can help a user to tune <a class="el" href="struct__drreg__options__t.html#a6bbbd6b9f361d671cec4c6bd0142259d">drreg_options_t.num_spill_slots</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>The maximum number of spill slots used is written here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. In release build, this routine always fails. </dd></dl>

</div>
</div>
<a id="ga39a587dee2fc48409d6486ab5fd91e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a587dee2fc48409d6486ab5fd91e74">&#9670;&nbsp;</a></span>drreg_reservation_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_reservation_info </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a> *opnd&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *is_dr_slot&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *tls_offs&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information about the TLS slot assigned to <code>reg</code>, which must be a currently-reserved register. To query information about the arithmetic flags, pass <a class="el" href="dr__ir__opnd_8h.html#ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882">DR_REG_NULL</a> for <code>reg</code>.</p>
<p>If <code>opnd</code> is non-NULL, returns an <a class="el" href="structopnd__t.html">opnd_t</a> in <code>opnd</code> that references the TLS slot assigned to <code>reg</code>. If too many slots are in use and <code>reg</code> is stored in a non-directly-addressable slot, returns a null <a class="el" href="structopnd__t.html">opnd_t</a> in <code>opnd</code>.</p>
<p>If <code>is_dr_slot</code> is non-NULL, returns true if the slot is a DR slot (and can thus be accessed by <a class="el" href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg()</a>) and false if the slot is inside the <a class="el" href="dr__tools_8h.html#ac5d2a2ccd58268f84c379a38bc4aa399">dr_raw_tls_calloc()</a> allocation used by drreg.</p>
<p>If <code>tls_offs</code> is non-NULL, if the slot is a DR slot, returns the DR slot index; otherwise, returns the offset from the TLS base of the slot assigned to <code>reg</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gad8ff9a156f64e7146284385f2a26c8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8ff9a156f64e7146284385f2a26c8e4">&#9670;&nbsp;</a></span>drreg_reservation_info_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_reservation_info_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drreg.html#ga1a91ecc67def444d5922a58fe0f641e4">drreg_reserve_info_t</a> *info&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information about the reservation and restoration status of <code>reg</code>. The <code>size</code> field of <code>info</code> must be set before calling. To query information about the arithmetic flags, pass <a class="el" href="dr__ir__opnd_8h.html#ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882">DR_REG_NULL</a> for <code>reg</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga5dafaf790ed3811076311d57b037a800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dafaf790ed3811076311d57b037a800">&#9670;&nbsp;</a></span>drreg_reserve_aflags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_reserve_aflags </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests exclusive use of the arithmetic flags register. Spills the application value at <code>where</code> in <code>ilist</code>, if necessary. When used during drmgr's insertion phase, optimizations such as keeping the application flags value in a register and eliding duplicate spills and restores will be automatically applied. If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<p>TODO i#3823: Support multi-phase use. This will require adding support to spill aflags to slots other than AFLAGS_SLOT.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga83416a76d3e020f4c7f86036dbe98824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83416a76d3e020f4c7f86036dbe98824">&#9670;&nbsp;</a></span>drreg_reserve_dead_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_reserve_dead_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>reg_allowed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="group__drreg.html#gab922bcd0f9216884db35f2e6423f6337">drreg_reserve_register()</a> except returns failure if no register is available that does not require a spill.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gab922bcd0f9216884db35f2e6423f6337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab922bcd0f9216884db35f2e6423f6337">&#9670;&nbsp;</a></span>drreg_reserve_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_reserve_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>reg_allowed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests exclusive use of an application register, spilling the application value at <code>where</code> in <code>ilist</code> if necessary. The register chosen is returned in <code>reg</code>.</p>
<p>When used during drmgr's insertion phase, optimizations such as keeping the application flags value in a register and eliding duplicate spills and restores will be automatically applied. If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<p>If <code>reg_allowed</code> is non-NULL, only registers from the specified set will be considered, where <code>reg_allowed</code> must be a vector with one entry for each general-purpose register in [<a class="el" href="dr__ir__opnd_8h.html#a4ca9d6df48c16d2956a306b382034611">DR_REG_START_GPR</a>..<a class="el" href="dr__ir__opnd_8h.html#a24ceac3fd7c6c0d0d3bda89426e27f3a">DR_REG_STOP_GPR</a>] where a NULL entry indicates not allowed and any non-NULL entry indicates allowed. The <a class="el" href="group__drreg.html#gad5d81ea8114d9aea29b340dd034cda04">drreg_init_and_fill_vector()</a> routine can be used to set up <code>reg_allowed</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gad7fbf107e7b10fffb8da7d93b74153c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7fbf107e7b10fffb8da7d93b74153c4">&#9670;&nbsp;</a></span>drreg_restore_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_restore_all </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores the spilled value (typically the application value) for all registers and flags at <code>where</code>. </p>

</div>
</div>
<a id="gae2ba110d4aca864533583a53f8e04d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ba110d4aca864533583a53f8e04d40">&#9670;&nbsp;</a></span>drreg_restore_app_aflags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_restore_app_aflags </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine ensures that the application's value for the arithmetic flags is in place prior to <code>where</code>. This is automatically done when the flags are reserved prior to an application instruction, but sometimes instrumentation needs to read the value of the flags. This is intended as a convenience barrier for lazy restores performed by drreg.</p>
<p>If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<p>TODO i#3823: Support multi-phase use. This will require adding support to spill aflags to slots other than AFLAGS_SLOT.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="gaf3a0543b8c49f5bb7af6cae384af34d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a0543b8c49f5bb7af6cae384af34d2">&#9670;&nbsp;</a></span>drreg_restore_app_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_restore_app_values </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a convenience routine that calls <a class="el" href="group__drreg.html#ga52ef72f8179e3a1eff9f74cab9d733c4">drreg_get_app_value()</a> for every register used by <code>opnd</code>, with that register passed as the application and destination registers. This routine will write to reserved as well as unreserved registers. This is intended as a convenience barrier for lazy restores performed by drreg.</p>
<p>If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<p>On ARM, asking to place the application value of the register returned by <a class="el" href="dr__ir__utils_8h.html#ad7af9296c9f5930b025186aea0688b13">dr_get_stolen_reg()</a> into itself is not supported. If <code>opnd</code> uses the stolen register, this routine will swap it for a scratch register. This scratch register will be <code>*swap</code> if <code>*swap</code> is not <a class="el" href="dr__ir__opnd_8h.html#ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882">DR_REG_NULL</a>; otherwise, <a class="el" href="group__drreg.html#gab922bcd0f9216884db35f2e6423f6337">drreg_reserve_register()</a> with NULL for <code>reg_allowed</code> will be called, and the result returned in <code>*swap</code>. It is up to the caller to un-reserve the register in that case.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. On failure, any values that were already restored are not undone. </dd></dl>

</div>
</div>
<a id="ga7910ab166b0d698c11964a7b89d90faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7910ab166b0d698c11964a7b89d90faf">&#9670;&nbsp;</a></span>drreg_set_bb_properties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_set_bb_properties </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drreg.html#ga9aa35aebc3d4f0f41cba66bfcde82a00">drreg_bb_properties_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May only be called during drmgr's app2app, analysis, or insertion phase. Sets the given properties for the current basic block being instrumented.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga2878afd0bb1dcc73ebf1eb99a83748ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2878afd0bb1dcc73ebf1eb99a83748ce">&#9670;&nbsp;</a></span>drreg_set_vector_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_set_vector_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the entry in <code>vec</code> at index <code>reg</code> minus <a class="el" href="dr__ir__opnd_8h.html#a4ca9d6df48c16d2956a306b382034611">DR_REG_START_GPR</a> to NULL if <code>allowed</code> is false or a non-NULL value if <code>allowed</code> is true. This is intendend as a convenience routine for setting up the <code>reg_allowed</code> parameter to <a class="el" href="group__drreg.html#gab922bcd0f9216884db35f2e6423f6337">drreg_reserve_register()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga2ca98376d910bf8b417d60954193cae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca98376d910bf8b417d60954193cae1">&#9670;&nbsp;</a></span>drreg_statelessly_restore_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_statelessly_restore_all </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where_restore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where_respill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *restore_needed&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *respill_needed&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invokes <a class="el" href="group__drreg.html#ga4dd4dc9f52ffd96616ee1eb92ebd5a9c">drreg_statelessly_restore_app_value()</a> for the arithmetic flags and every general-purpose register. Returns the logical OR of the 'restore_needed' and 'respill_needed' results from all of the <a class="el" href="group__drreg.html#ga4dd4dc9f52ffd96616ee1eb92ebd5a9c">drreg_statelessly_restore_app_value()</a> calls. If any step results in an error, that error is returned and the output parameters are not filled in (despite partial restores potentially remaining in place). </p>

</div>
</div>
<a id="ga4dd4dc9f52ffd96616ee1eb92ebd5a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd4dc9f52ffd96616ee1eb92ebd5a9c">&#9670;&nbsp;</a></span>drreg_statelessly_restore_app_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_statelessly_restore_app_value </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where_restore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where_respill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *restore_needed&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *respill_needed&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine is meant for use with instrumentation that uses separate control flow paths, such as a fastpath and a slowpath, where the slowpath needs access to the full application state yet must retain scratch register parity with the fastpath. The application value for <code>reg</code> is restored into <code>reg</code> at <code>where_restore</code>, but internal drreg state is not updated to reflect this. Furthermore, if doing so affects subsequent behavior, such as when <code>reg</code> is being used to hold the preserved application value for another register or flags, instructions are inserted at <code>where_respill</code> to restore the state, such that <code>where_respill</code> will operate correctly whether <code>where_restore</code> was executed or not. The optional output parameters <code>restore_needed</code> and <code>respill_needed</code> are set to indicate whether instructions were inserted at <code>where_restore</code> and <code>where_respill</code>, respectively.</p>
<p>For correct operation on x86 in the case when aflags are in xax and this routine is invoked to get app value of xax, there shouldn't be any new reservation between <code>where_restore</code> and <code>where_respill</code> that may write to a spill slot and clobber the temporary slot used in this routine.</p>
<p>The results from <a class="el" href="group__drreg.html#gad8ff9a156f64e7146284385f2a26c8e4">drreg_reservation_info_ex()</a> can be used to predict the behavior of this routine. A restore is needed if !drreg_reserve_info_t.holds_app_value. and <a class="el" href="struct__drreg__reserve__info__t.html#ae89cf72819d8b01016d58a8c2c83b53e">drreg_reserve_info_t.app_value_retained</a>. A respill is needed if a restore is needed and <a class="el" href="struct__drreg__reserve__info__t.html#a4a12304127b48c83d2270760ff587983">drreg_reserve_info_t.opnd</a> is a register.</p>
<p>If <code>app_reg</code> is a dead register, <a class="el" href="group__drreg.html#ggad5b7a7a020d7206b11e61e7cdae02ee9a1f21cc5ebb7031b6430b3cdb2a21ddf8">DRREG_ERROR_NO_APP_VALUE</a> may be returned. Set <code>conservative</code> in <code>drreg_options_t</code> to avoid this error.</p>
<p>If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<p>To restore the arithmetic flags, pass <a class="el" href="dr__ir__opnd_8h.html#ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882">DR_REG_NULL</a> for <code>reg</code>.</p>
<p>On ARM, passing <code>reg</code> equal to <a class="el" href="dr__ir__utils_8h.html#ad7af9296c9f5930b025186aea0688b13">dr_get_stolen_reg()</a> is not supported.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga5e6f06ca372fef0437652ba8915fc09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e6f06ca372fef0437652ba8915fc09d">&#9670;&nbsp;</a></span>drreg_unreserve_aflags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_unreserve_aflags </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminates exclusive use of the arithmetic flags register. Restores the application value at <code>where</code> in <code>ilist</code>, if necessary. If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga3226af61d5322e93c97546e49d79d983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3226af61d5322e93c97546e49d79d983">&#9670;&nbsp;</a></span>drreg_unreserve_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drreg.html#gad5b7a7a020d7206b11e61e7cdae02ee9">drreg_status_t</a> drreg_unreserve_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminates exclusive use of the register <code>reg</code>. Restores the application value at <code>where</code> in <code>ilist</code>, if necessary. If called during drmgr's insertion phase, <code>where</code> must be the current application instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful or an error code on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
