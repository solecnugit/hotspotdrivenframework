---
title: "/clients/include/drmemtrace/drmemtrace.h File Reference"
layout: default
permalink: /drmemtrace_8h.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_1036706e55c22cab35bc1c58ee689f1d.html">runner</a></li><li class="navelem"><a class="el" href="dir_629f8151d55d307162ff2d619fb1783d.html">work</a></li><li class="navelem"><a class="el" href="dir_84b917e355554dd3f3793c21ab4ddcaf.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_afee7b8fe0b60d0be677a736c14882ae.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_489b6e853deb4fa1d1f97a1bc0ffc492.html">build_release-64</a></li><li class="navelem"><a class="el" href="dir_df1c9b8dec9570292811787b08f6a8e3.html">clients</a></li><li class="navelem"><a class="el" href="dir_fd9d80edd0488d8eb4462511de32d249.html">include</a></li><li class="navelem"><a class="el" href="dir_454719cbcf9926828d9a4568d3bcefeb.html">drmemtrace</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drmemtrace.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header for customizing the DrMemtrace tracer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a015a9ac79ac244f338bb44ad12d2d958"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a015a9ac79ac244f338bb44ad12d2d958">DRMGR_PRIORITY_NAME_MEMTRACE</a>&#160;&#160;&#160;&quot;memtrace&quot;</td></tr>
<tr class="separator:a015a9ac79ac244f338bb44ad12d2d958"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aae6fa7e54f417740124583a6528a53cf"><td class="memItemLeft" align="right" valign="top">typedef file_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#aae6fa7e54f417740124583a6528a53cf">drmemtrace_open_file_func_t</a>) (const char *fname, uint mode_flags)</td></tr>
<tr class="separator:aae6fa7e54f417740124583a6528a53cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd7618d895044548608c53cf4f00793"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a8cd7618d895044548608c53cf4f00793">drmemtrace_read_file_func_t</a>) (file_t file, void *buf, size_t count)</td></tr>
<tr class="separator:a8cd7618d895044548608c53cf4f00793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a2d9ed70af36dc07f442ce5aef2bb4"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a83a2d9ed70af36dc07f442ce5aef2bb4">drmemtrace_write_file_func_t</a>) (file_t file, const void *data, size_t count)</td></tr>
<tr class="separator:a83a2d9ed70af36dc07f442ce5aef2bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9567b547780e26ff3cbd6667c9728"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a9fd9567b547780e26ff3cbd6667c9728">drmemtrace_close_file_func_t</a>) (file_t file)</td></tr>
<tr class="separator:a9fd9567b547780e26ff3cbd6667c9728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5540d82f676fd45849f024fe8cba0d1"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#ac5540d82f676fd45849f024fe8cba0d1">drmemtrace_create_dir_func_t</a>) (const char *dir)</td></tr>
<tr class="separator:ac5540d82f676fd45849f024fe8cba0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474060a7301f542953030461e2adedef"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a474060a7301f542953030461e2adedef">drmemtrace_handoff_func_t</a>) (file_t file, void *data, size_t data_size, size_t alloc_size)</td></tr>
<tr class="separator:a474060a7301f542953030461e2adedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfd46ef1d6d3866dec6becf9a0d3730"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#afcfd46ef1d6d3866dec6becf9a0d3730">drmemtrace_exit_func_t</a>) (void *arg)</td></tr>
<tr class="separator:afcfd46ef1d6d3866dec6becf9a0d3730"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a74f96316a038d687c65092c9b9e645e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> { <br />
&#160;&#160;<a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9ade770eb6a525f08ed21fe9186350ddaa">DRMEMTRACE_SUCCESS</a>, 
<br />
&#160;&#160;<a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9ac50f21eecf39b36f0f948bd21aa4f11c">DRMEMTRACE_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9a2b4a0aec301f7d7542e77c5b250c1648">DRMEMTRACE_ERROR_INVALID_PARAMETER</a>, 
<br />
&#160;&#160;<a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9a64ef8cc766a0d3c849f77e5f61dd54cd">DRMEMTRACE_ERROR_NOT_IMPLEMENTED</a>
<br />
 }</td></tr>
<tr class="separator:a74f96316a038d687c65092c9b9e645e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab21913507ae5665dd43fd24a20cbf03c"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#ab21913507ae5665dd43fd24a20cbf03c">drmemtrace_client_main</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> id, int argc, const char *argv[])</td></tr>
<tr class="separator:ab21913507ae5665dd43fd24a20cbf03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7be083ae67d4a389be1eb1c5fe1b6e"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#abb7be083ae67d4a389be1eb1c5fe1b6e">drmemtrace_replace_file_ops</a> (<a class="el" href="drmemtrace_8h.html#aae6fa7e54f417740124583a6528a53cf">drmemtrace_open_file_func_t</a> open_file_func, <a class="el" href="drmemtrace_8h.html#a8cd7618d895044548608c53cf4f00793">drmemtrace_read_file_func_t</a> read_file_func, <a class="el" href="drmemtrace_8h.html#a83a2d9ed70af36dc07f442ce5aef2bb4">drmemtrace_write_file_func_t</a> write_file_func, <a class="el" href="drmemtrace_8h.html#a9fd9567b547780e26ff3cbd6667c9728">drmemtrace_close_file_func_t</a> close_file_func, <a class="el" href="drmemtrace_8h.html#ac5540d82f676fd45849f024fe8cba0d1">drmemtrace_create_dir_func_t</a> create_dir_func)</td></tr>
<tr class="separator:abb7be083ae67d4a389be1eb1c5fe1b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134b8c5296c9f977a862c2667ec823b1"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a134b8c5296c9f977a862c2667ec823b1">drmemtrace_buffer_handoff</a> (<a class="el" href="drmemtrace_8h.html#a474060a7301f542953030461e2adedef">drmemtrace_handoff_func_t</a> handoff_func, <a class="el" href="drmemtrace_8h.html#afcfd46ef1d6d3866dec6becf9a0d3730">drmemtrace_exit_func_t</a> exit_func, void *exit_func_arg)</td></tr>
<tr class="separator:a134b8c5296c9f977a862c2667ec823b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788e3e4e25b13c1f6148a8fd544b2d81"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a788e3e4e25b13c1f6148a8fd544b2d81">drmemtrace_get_output_path</a> (OUT const char **path)</td></tr>
<tr class="separator:a788e3e4e25b13c1f6148a8fd544b2d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c93fd7bcda89efb7786ad0cf27f8ff2"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a8c93fd7bcda89efb7786ad0cf27f8ff2">drmemtrace_get_modlist_path</a> (OUT const char **path)</td></tr>
<tr class="separator:a8c93fd7bcda89efb7786ad0cf27f8ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc71b61ef30155adbc03800ce7597261"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#abc71b61ef30155adbc03800ce7597261">drmemtrace_get_funclist_path</a> (OUT const char **path)</td></tr>
<tr class="separator:abc71b61ef30155adbc03800ce7597261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644981035cdedfafb000d03cd223399"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a8644981035cdedfafb000d03cd223399">drmemtrace_custom_module_data</a> (void *(*load_cb)(<a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *module, int seg_idx), int(*print_cb)(void *data, char *dst, size_t max_len), void(*free_cb)(void *data))</td></tr>
<tr class="separator:a8644981035cdedfafb000d03cd223399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e640ae52a85bcd0eb544087d264672a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a8e640ae52a85bcd0eb544087d264672a">drmemtrace_filter_threads</a> (bool(*should_trace_thread_cb)(thread_id_t tid, void *user_data), void *user_value)</td></tr>
<tr class="separator:a8e640ae52a85bcd0eb544087d264672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2178d62155d7875efef8c8def5da0b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="drmemtrace_8h.html#a7a2178d62155d7875efef8c8def5da0b">drmemtrace_get_timestamp_from_offline_trace</a> (const void *trace, size_t trace_size, OUT uint64 *timestamp)</td></tr>
<tr class="separator:a7a2178d62155d7875efef8c8def5da0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header for customizing the DrMemtrace tracer. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a015a9ac79ac244f338bb44ad12d2d958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015a9ac79ac244f338bb44ad12d2d958">&#9670;&nbsp;</a></span>DRMGR_PRIORITY_NAME_MEMTRACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_MEMTRACE&#160;&#160;&#160;&quot;memtrace&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of drmgr instrumentation pass priorities for app2app, analysis, insert, and instru2instru. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9fd9567b547780e26ff3cbd6667c9728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd9567b547780e26ff3cbd6667c9728">&#9670;&nbsp;</a></span>drmemtrace_close_file_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* drmemtrace_close_file_func_t) (file_t file)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for file close. The example behavior is described in <a class="el" href="dr__tools_8h.html#a2f9ce8187cd9bff18c879978a9ab1b8a">dr_close_file()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5540d82f676fd45849f024fe8cba0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5540d82f676fd45849f024fe8cba0d1">&#9670;&nbsp;</a></span>drmemtrace_create_dir_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* drmemtrace_create_dir_func_t) (const char *dir)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for directory creation. The example behavior is described in <a class="el" href="dr__tools_8h.html#a0317a4764f0d04b5510fcfd418131a4c">dr_create_dir()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>The directory name for creation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="afcfd46ef1d6d3866dec6becf9a0d3730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfd46ef1d6d3866dec6becf9a0d3730">&#9670;&nbsp;</a></span>drmemtrace_exit_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* drmemtrace_exit_func_t) (void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for process exit. This is called during the tracer shutdown, giving a control point where DR memory may be accessed, which is not possible when acting after <a class="el" href="dr__app_8h.html#a7e062573c669d8a5564abf54ebf90f31">dr_app_stop_and_cleanup()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The <code>exit_func_arg</code> passed to <a class="el" href="drmemtrace_8h.html#a134b8c5296c9f977a862c2667ec823b1">drmemtrace_buffer_handoff()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a474060a7301f542953030461e2adedef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474060a7301f542953030461e2adedef">&#9670;&nbsp;</a></span>drmemtrace_handoff_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* drmemtrace_handoff_func_t) (file_t file, void *data, size_t data_size, size_t alloc_size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for buffer handoff. Rather than writing a buffer to a file when it is full, instead this handoff function gives ownership to the callee. The tracer allocates a new buffer and uses it for further tracing. The callee is responsible for writing out the buffer and for freeing it by calling <a class="el" href="dr__tools_8h.html#aee58c732aec96032bcd5344104ef626c">dr_raw_mem_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file identifier returned by <code>open_file_func</code> or or <a class="el" href="drmemtrace_8h.html#abb7be083ae67d4a389be1eb1c5fe1b6e">drmemtrace_replace_file_ops()</a> was not called then from <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a> for the per-thread trace file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The start address of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>The size of valid trace data in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_size</td><td>The allocated size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. Failure is considered unrecoverable. </dd></dl>

</div>
</div>
<a id="aae6fa7e54f417740124583a6528a53cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6fa7e54f417740124583a6528a53cf">&#9670;&nbsp;</a></span>drmemtrace_open_file_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef file_t(* drmemtrace_open_file_func_t) (const char *fname, uint mode_flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for file open. The file access mode is set by the <code>mode_flags</code> argument which is drawn from the DR_FILE_* defines ORed together. Returns INVALID_FILE if unsuccessful. The example behavior is described in <a class="el" href="dr__tools_8h.html#a8c1399687e4cbc3c0b9bddab3e7619d3">dr_open_file()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>The filename to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode_flags</td><td>The DR_FILE_* flags for file open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the opened file id. </dd></dl>

</div>
</div>
<a id="a8cd7618d895044548608c53cf4f00793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd7618d895044548608c53cf4f00793">&#9670;&nbsp;</a></span>drmemtrace_read_file_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* drmemtrace_read_file_func_t) (file_t file, void *buf, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for file read. Reads up to <code>count</code> bytes from file <code>file</code> into <code>buf</code>. Returns the actual number read. The example behavior is described in <a class="el" href="dr__tools_8h.html#ac9600abc55b7ed7e283e6d8a9dee1ecc">dr_read_file()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>The buffer to be read to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual number of bytes read. </dd></dl>

</div>
</div>
<a id="a83a2d9ed70af36dc07f442ce5aef2bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a2d9ed70af36dc07f442ce5aef2bb4">&#9670;&nbsp;</a></span>drmemtrace_write_file_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* drmemtrace_write_file_func_t) (file_t file, const void *data, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for file write. Writes <code>count</code> bytes from <code>data</code> to file <code>file</code>. Returns the actual number written. The example behavior is described in <a class="el" href="dr__tools_8h.html#a451ff3e57783acbfdf24c1e557145807">dr_write_file()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual number of bytes written. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a74f96316a038d687c65092c9b9e645e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f96316a038d687c65092c9b9e645e9">&#9670;&nbsp;</a></span>drmemtrace_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Status return values from drmemtrace functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a74f96316a038d687c65092c9b9e645e9ade770eb6a525f08ed21fe9186350ddaa"></a>DRMEMTRACE_SUCCESS&#160;</td><td class="fielddoc"><p>Operation succeeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a74f96316a038d687c65092c9b9e645e9ac50f21eecf39b36f0f948bd21aa4f11c"></a>DRMEMTRACE_ERROR&#160;</td><td class="fielddoc"><p>Operation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a74f96316a038d687c65092c9b9e645e9a2b4a0aec301f7d7542e77c5b250c1648"></a>DRMEMTRACE_ERROR_INVALID_PARAMETER&#160;</td><td class="fielddoc"><p>Operation failed: invalid parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="a74f96316a038d687c65092c9b9e645e9a64ef8cc766a0d3c849f77e5f61dd54cd"></a>DRMEMTRACE_ERROR_NOT_IMPLEMENTED&#160;</td><td class="fielddoc"><p>Operation failed: not implemented. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a134b8c5296c9f977a862c2667ec823b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134b8c5296c9f977a862c2667ec823b1">&#9670;&nbsp;</a></span>drmemtrace_buffer_handoff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_buffer_handoff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drmemtrace_8h.html#a474060a7301f542953030461e2adedef">drmemtrace_handoff_func_t</a>&#160;</td>
          <td class="paramname"><em>handoff_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drmemtrace_8h.html#afcfd46ef1d6d3866dec6becf9a0d3730">drmemtrace_exit_func_t</a>&#160;</td>
          <td class="paramname"><em>exit_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>exit_func_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a function to replace the default file write operation for offline tracing and requests that buffer ownership be transfered. The regular file open and close routines (or their replacements from <a class="el" href="drmemtrace_8h.html#abb7be083ae67d4a389be1eb1c5fe1b6e">drmemtrace_replace_file_ops()</a>) will be called, but instead of writing to the files (or calling the <code>write_file_func</code>), the provided <code>handoff_func</code> will be called instead. The callee is responsible for writing out the buffer and for freeing it by calling <a class="el" href="dr__tools_8h.html#aee58c732aec96032bcd5344104ef626c">dr_raw_mem_free()</a>. The amount of legitimate data is in <code>data_size</code> and the total allocated size of the buffer is in <code>alloc_size</code>. Any space in between is available for use by the callee. The return value of <code>handoff_cb</code> indicates whether successful or not: failure will be treated as fatal and unrecoverable.</p>
<p>The module list data, written to the first file opened, is not subject to this ownership transfer and uses the <code>write_file_func</code>.</p>
<p>Because DR memory will be freed in <a class="el" href="dr__app_8h.html#a7e062573c669d8a5564abf54ebf90f31">dr_app_stop_and_cleanup()</a>, an exit callback is provided for a control point to process and free the buffers. When <a class="el" href="dr__app_8h.html#a7e062573c669d8a5564abf54ebf90f31">dr_app_stop_and_cleanup()</a> is used, <code>exit_func</code> will be called (and passed <code>exit_func_arg</code>) after the other application threads are already native.</p>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for the transparency and isolation of using these functions, which will be called in the middle of arbitrary application code. </dd></dl>

</div>
</div>
<a id="ab21913507ae5665dd43fd24a20cbf03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21913507ae5665dd43fd24a20cbf03c">&#9670;&nbsp;</a></span>drmemtrace_client_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drmemtrace_client_main </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To support statically linking multiple clients on UNIX, <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> inside drmemtrace is a weak symbol which just calls the real initializer <a class="el" href="drmemtrace_8h.html#ab21913507ae5665dd43fd24a20cbf03c">drmemtrace_client_main()</a>. An enclosing application can override <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> and invoke <a class="el" href="drmemtrace_8h.html#ab21913507ae5665dd43fd24a20cbf03c">drmemtrace_client_main()</a> explicitly at a time of its choosing. </p>

</div>
</div>
<a id="a8644981035cdedfafb000d03cd223399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8644981035cdedfafb000d03cd223399">&#9670;&nbsp;</a></span>drmemtrace_custom_module_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_custom_module_data </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *module, int seg_idx)&#160;</td>
          <td class="paramname"><em>load_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *data, char *dst, size_t max_len)&#160;</td>
          <td class="paramname"><em>print_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *data)&#160;</td>
          <td class="paramname"><em>free_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds custom data stored with each module in the module list produced for offline trace post-processing. The <code>load_cb</code> is called for each segment of each new module (with <code>seg_idx</code> indicating the segment number, starting at 0), and its return value is the data that is stored. That data is later printed to a string with <code>print_cb</code>, which should return the number of characters printed or -1 on error. The data is freed with <code>free_cb</code>. Each is called separately for each segment of each module.</p>
<p>On the post-processing side, the user should create a custom post-processor by linking with raw2trace and calling <a class="el" href="classraw2trace__t.html#ae88903e56d49c6118d9bd34874794b6b">raw2trace_t::handle_custom_data()</a> to provide parsing and processing routines for the custom data. </p>

</div>
</div>
<a id="a8e640ae52a85bcd0eb544087d264672a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e640ae52a85bcd0eb544087d264672a">&#9670;&nbsp;</a></span>drmemtrace_filter_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_filter_threads </td>
          <td>(</td>
          <td class="paramtype">bool(*)(thread_id_t tid, void *user_data)&#160;</td>
          <td class="paramname"><em>should_trace_thread_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activates thread filtering. The <code>should_trace_thread_cb</code> will be called once for each new thread, with <code>user_value</code> passed in for <code>user_data</code>. If it returns false, that thread will <em>not</em> be traced at all; if it returns true, that thread will be traced normally. Returns whether the filter was successfully installed. </p><dl class="section note"><dt>Note</dt><dd>This feature is currently only supported for x86. This routine should be called during initialization, before any instrumentation is added. To filter out the calling thread (the initial application thread) this should be called prior to DR initialization (via the start/stop API). Only a single call to this routine is supported. </dd></dl>

</div>
</div>
<a id="abc71b61ef30155adbc03800ce7597261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc71b61ef30155adbc03800ce7597261">&#9670;&nbsp;</a></span>drmemtrace_get_funclist_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_get_funclist_path </td>
          <td>(</td>
          <td class="paramtype">OUT const char **&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the full path to the file in -offline mode where function tracing information is written. The basename of the file is <a class="el" href="trace__entry_8h.html#a9d41aaff6406ac94cd98ee7c95cd0753">DRMEMTRACE_FUNCTION_LIST_FILENAME</a>. Each "library!symbol" function that was traced occupies one line of the file, with comma-separated values preceding it: its numeric identifier used in trace entries; the number of its arguments that are recorded; its address in hexadecimal format; and optional flags such as "noret". For example:</p>
<p>4,1,0x7fff2348ac,libc!malloc 5,1,0x7fff267d52,noret,libc!free</p>
<p>There can be multiple symbols mapping to the same address and thus to the sam identifier; each will have its own line in the file. </p>

</div>
</div>
<a id="a8c93fd7bcda89efb7786ad0cf27f8ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c93fd7bcda89efb7786ad0cf27f8ff2">&#9670;&nbsp;</a></span>drmemtrace_get_modlist_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_get_modlist_path </td>
          <td>(</td>
          <td class="paramtype">OUT const char **&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the full path to the file in -offline mode where module data is written. The basename of the file is <a class="el" href="trace__entry_8h.html#a11362437617ea146f226243e4de7ce7b">DRMEMTRACE_MODULE_LIST_FILENAME</a>. Its creation can be customized using <a class="el" href="drmemtrace_8h.html#a8644981035cdedfafb000d03cd223399">drmemtrace_custom_module_data()</a> with corresponding post-processing with <a class="el" href="classraw2trace__t.html#ae88903e56d49c6118d9bd34874794b6b">raw2trace_t::handle_custom_data()</a>. </p>

</div>
</div>
<a id="a788e3e4e25b13c1f6148a8fd544b2d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788e3e4e25b13c1f6148a8fd544b2d81">&#9670;&nbsp;</a></span>drmemtrace_get_output_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_get_output_path </td>
          <td>(</td>
          <td class="paramtype">OUT const char **&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the full path to the output directory in -offline mode where data is being written. </p>

</div>
</div>
<a id="a7a2178d62155d7875efef8c8def5da0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2178d62155d7875efef8c8def5da0b">&#9670;&nbsp;</a></span>drmemtrace_get_timestamp_from_offline_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_get_timestamp_from_offline_trace </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>trace_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint64 *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch the timestamp from a raw trace bundle. The API checks if the bundle is a thread start or not, and fetches the timestamp from the appropriate location. Returns DRMEMTRACE_ERROR_INVALID_PARAMETER if the pointer parameters are null or if the trace is too short. </p>

</div>
</div>
<a id="abb7be083ae67d4a389be1eb1c5fe1b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7be083ae67d4a389be1eb1c5fe1b6e">&#9670;&nbsp;</a></span>drmemtrace_replace_file_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="drmemtrace_8h.html#a74f96316a038d687c65092c9b9e645e9">drmemtrace_status_t</a> drmemtrace_replace_file_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drmemtrace_8h.html#aae6fa7e54f417740124583a6528a53cf">drmemtrace_open_file_func_t</a>&#160;</td>
          <td class="paramname"><em>open_file_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drmemtrace_8h.html#a8cd7618d895044548608c53cf4f00793">drmemtrace_read_file_func_t</a>&#160;</td>
          <td class="paramname"><em>read_file_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drmemtrace_8h.html#a83a2d9ed70af36dc07f442ce5aef2bb4">drmemtrace_write_file_func_t</a>&#160;</td>
          <td class="paramname"><em>write_file_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drmemtrace_8h.html#a9fd9567b547780e26ff3cbd6667c9728">drmemtrace_close_file_func_t</a>&#160;</td>
          <td class="paramname"><em>close_file_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drmemtrace_8h.html#ac5540d82f676fd45849f024fe8cba0d1">drmemtrace_create_dir_func_t</a>&#160;</td>
          <td class="paramname"><em>create_dir_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers functions to replace the default file operations for offline tracing.</p>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for the transparency and isolation of using those functions, which will be called in the middle of arbitrary application code. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:55 &nbsp; <img border=0 src="favicon.png">
</small></address>
