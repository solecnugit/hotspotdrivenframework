---
title: "Client Transparency"
layout: default
permalink: /transparency.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Client Transparency </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>DynamoRIO must avoid interfering with the semantics of a program while it executes. Shifting execution from the original application code into a cache that occupies the application's own address space provides flexibility but complicates transparency. To achieve transparency, DynamoRIO cannot make any assumptions about a program's stack usage, heap usage, or any of its dependencies on the instruction set architecture or operating system. DynamoRIO's transparency restrictions necessarily apply to a client as well.</p>
<p>Contents:</p><ul>
<li><a class="el" href="transparency.html#sec_trans_resource">Resource Usage Conflicts</a></li>
<li><a class="el" href="transparency.html#sec_trans_unmod">Leaving the Application Unchanged When Possible</a></li>
<li><a class="el" href="transparency.html#sec_trans_pretend">Pretending The Application Is Unchanged When It Is Not</a></li>
<li><a class="el" href="transparency.html#sec_trans_alertable">Alertable System Calls</a></li>
</ul>
<p>We first describe each of the three transparency categories for DynamoRIO and their ramifications for clients using the code cache.</p>
<h1><a class="anchor" id="sec_trans_resource"></a>
Resource Usage Conflicts</h1>
<p>Ideally, DynamoRIO and its client's resources should be completely disjoint from the application's, to avoid conflicts in the usage of libraries, heap, input/output, and locks. Library conflicts are the most relevant to a client.</p>
<dl class="section user"><dt>Library Transparency</dt><dd></dd></dl>
<p>Sharing libraries with the application can cause problems with re-entrancy and corruption of persistent state like error codes. DynamoRIO's dispatch code can execute at arbitrary points in the middle of application code; a client's instrumentation is similarly executed. If both the application and DynamoRIO use the same non-re-entrant library routine, DynamoRIO might call the routine while the application is inside it, causing incorrect behavior. We have learned this lesson the hard way, having run into it several times. The solution is for DynamoRIO's external resources to come only from system calls and never from user libraries. This is straightforward to accomplish on Linux, and most operating systems, where the system call interface is a standard mechanism for requesting services (<em>a</em> in the figure below). However, on Windows, the documented method of interacting with the operating system is not via system calls but instead through an application programming interface (the {<em>Win32</em> API}) built with user libraries on top of the system call interface (<em>b</em> in the figure). If DynamoRIO uses this interface, re-entrancy and other resource usage conflicts can, and will, occur. To achieve full transparency on Windows, the system call interface (<em>c</em> in the figure) must be used, rather than the API layer.</p>
<div class="image">
<img src="/images/windows.png" alt=""/>
</div>
  <p>DynamoRIO provides access to resources to clients via a cross-platform API. We do not recommend that a client invoke its own system calls as this bypasses DynamoRIO's monitoring of changes to the process address space and changes to threads or control flow.</p>
<p>DynamoRIO does have its own loader and through it support is provided to clients to use external libraries while isolating them from the libraries used by the application: see <a class="el" href="using.html#sec_extlibs">Using External Libraries</a>. This support is limited, however, and there are libraries that are not supported today.</p>
<p>In addition to Library Transparency, several other types of transparency are of concern to a client:</p>
<dl class="section user"><dt>Heap Transparency</dt><dd></dd></dl>
<p>Sharing heap allocation routines with the application violates Library Transparency. Most heap allocation routines are not re-entrant (they are thread-safe, but not re-entrant). Additionally, DynamoRIO should not interfere with the data layout of the application (Data Transparency: see below) or with application memory bugs (Error Transparency: see below). DynamoRIO obtains its memory directly from system calls and parcels it out internally with a custom memory manager. It exports its heap allocation routines through its API to ensure that clients maintain Heap Transparency (see <a class="el" href="using.html#sec_utils">Common Utilities</a>). Calls to malloc in external libraries used by clients are also redirected to DynamoRIO's internal heap.</p>
<dl class="section user"><dt>Input/Output Transparency</dt><dd></dd></dl>
<p>DynamoRIO uses its own input/output routines to avoid interfering with the application's buffering. As with heap transparency, DynamoRIO exports its input/output routines to clients to ensure that transparency is not violated (see <a class="el" href="using.html#sec_utils">Common Utilities</a>).</p>
<dl class="section user"><dt>Synchronization Transparency</dt><dd></dd></dl>
<p>DynamoRIO and its clients must avoid acquiring locks that the application also acquires, such as the <code>LoaderLock</code> on Windows. Additionally, there are restrictions imposed by DynamoRIO on when its own locks (including client locks) can be acquired, to allow it to safely synchronize with multiple threads: no lock should be held while application code is executing in the code cache. Locks can be used while inside client code reached from clean calls out of the code cache, but they must be released before returning to the cache. Failing to follow these restrictions can lead to deadlocks.</p>
<h1><a class="anchor" id="sec_trans_unmod"></a>
Leaving the Application Unchanged When Possible</h1>
<p>As many aspects of the application as possible should be left unchanged:</p>
<p><a class="anchor" id="sec_trans_floating_point"></a></p><dl class="section user"><dt>X87 Floating Point State Transparency</dt><dd></dd></dl>
<p>Because it is expensive to do so and rarely necessary, on x86 DynamoRIO does <em>NOT</em> save or restore the x87 floating point state or MMX (64-bit) registers during a context switch away from the application. The larger multimedia registers (XMM, YMM, ZMM, whether holding floating-point or integer values) are preserved, but if at any time a client wishes to use x87 floating point or MMX operations, it must explicitly preserve the state. The <a class="el" href="dr__ir__utils_8h.html#a1df44dbe3d8dbf82e63e96741f167c64">dr_insert_clean_call()</a> routine takes a boolean indicating whether x87 floating point state should be preserved across the call; this is the most convenient method for saving the state.</p>
<p>The state can alternatively be saved explicitly from C code using:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate</a>(<span class="keywordtype">byte</span> *buf)</div>
<div class="line"><a class="code" href="dr__proc_8h.html#aacb849daecc3021e451d9441b26cc814">proc_restore_fpstate</a>(<span class="keywordtype">byte</span> *buf)</div>
</div><!-- fragment --><p>Saving can be done from inlined code in the code cache using:</p>
<div class="fragment"><div class="line"><a class="code" href="dr__ir__utils_8h.html#aa23665c11b7d79a29ea185113d07944f">dr_insert_save_fpstate</a>(), <a class="code" href="dr__ir__utils_8h.html#a74016eacf3a9cfc20a93a9ac0bca9c59">dr_insert_restore_fpstate</a>() </div>
</div><!-- fragment --><p>These routines require a buffer that is 16-byte-aligned and of a certain size (512 bytes for processors with the FXSR feature, and 108 bytes for those without). Here is a sample usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">byte</span> fp_raw[512 + 16];</div>
<div class="line"><span class="keywordtype">byte</span> *fp_align = (<span class="keywordtype">byte</span> *) ( (((ptr_uint_t)fp_raw) + 16) &amp; ((ptr_uint_t)-16) );</div>
<div class="line"><a class="code" href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate</a>(fp_align);</div>
</div><!-- fragment --><p>Note that floating point operations include almost any operation that acts on a float, even printing one with %f, on older compilers. Modern compilers typically do not use x87 operations.</p>
<p>The XMM (128-bit) and larger registers are saved by DynamoRIO on context switches and clean calls. See also the <a class="el" href="dr__ir__utils_8h.html#a70dc8c6ccbd73b540991c5da347e65b2">dr_mcontext_xmm_fields_valid()</a> routine.</p>
<p>On ARM/AArch64, DynamoRIO saves and restores all the registers, including the SIMD/FP registers, during a context switch away from the application. The functions proc_save_fpstate and proc_restore_fpstate are provided, but do nothing.</p>
<p><a class="anchor" id="sec_trans_thread"></a></p><dl class="section user"><dt>Thread Transparency</dt><dd></dd></dl>
<p>For full transparency, if DynamoRIO or a client creates extra threads they should be hidden from any introspection performed by the application.</p>
<dl class="section user"><dt>Executable Transparency</dt><dd></dd></dl>
<p>The program binary and shared library files on disk should not be modified.</p>
<dl class="section user"><dt>Data Transparency</dt><dd></dd></dl>
<p>DynamoRIO leaves application data unmodified, including heap layout.</p>
<dl class="section user"><dt>Stack Transparency</dt><dd></dd></dl>
<p>The application stack must look exactly like it does natively. It is tempting to use the application stack for scratch space, but we have seen applications like Microsoft Office access data beyond the top of the stack (i.e., the application stores data on the top of the stack, moves the stack pointer to the previous location, and then accesses the data). Using the application stack for scratch space would clobber such data. Additionally, hand-crafted code might use the stack pointer as a general-purpose register. Other and better options for temporary space are available. DynamoRIO provides thread-local storage through its API.</p>
<p>DynamoRIO provides a separate stack to use for itself and for the client, and never assumes even that the application stack is valid. Many applications examine their stack and may not work properly if something is slightly different than expected.</p>
<h1><a class="anchor" id="sec_trans_pretend"></a>
Pretending The Application Is Unchanged When It Is Not</h1>
<p>For changes that are necessary (such as executing out of a code cache), DynamoRIO must warp events like interrupts, signals, and exceptions such that they appear to have occurred natively.</p>
<dl class="section user"><dt>Cache Consistency</dt><dd></dd></dl>
<p>DynamoRIO must keep its cached copies of the application code consistent with the actual copy in memory. If the application unloads a shared library and loads a new one in its place, or modifies its own code, DynamoRIO must change its code cache to reflect those changes to avoid incorrectly executing stale code. If the client needs to modify application code, it should do so through the basic block event, rather than directly.</p>
<dl class="section user"><dt>Address Space Transparency</dt><dd></dd></dl>
<p>DynamoRIO must pretend that it is not perturbing the application's address space. An application bug that writes to invalid memory and generates an exception should do the same thing under DynamoRIO, even if we have allocated memory at that location that would natively have been invalid. This requires protecting all DynamoRIO memory from inadvertent (or malicious) writes by the application. Furthermore, DynamoRIO hides itself from introspection by manipulating memory queries.</p>
<dl class="section user"><dt>Application Address Transparency</dt><dd></dd></dl>
<p>Although the application's code is moved into a cache, every address manipulated by the application must remain an original application address. DynamoRIO must translate indirect branch targets from application addresses to code cache addresses, and conversely if a code cache address is ever exposed to the application, DynamoRIO must translate it back to its original application address. The latter occurs when the operating system hands a machine context to a signal or exception handler. In that case both the faulting or interrupted address and the complete register state must be made to look like the signal or exception occurred natively, rather than inside the code cache where it actually occurred.</p>
<p>To save space, DynamoRIO does not store any mappings from code cache state to application state. Since our cache consistency guarantees that the original application code cannot have changed since we built a fragment, we re-create the fragment from the original code, applying all the same transformations we applied when we first copied it into our code cache. We then walk through the reproduction and the code cache version in lockstep until we reach the target instruction. In order to accomplish this algorithm in code that has been modified or re-arranged by a client, DynamoRIO needs client support. We have not yet implemented this support. </p><dl class="section user"><dt>Error Transparency</dt><dd></dd></dl>
<p>Application errors under DynamoRIO must occur as they would natively. We accomplish this by maintaining Heap Transparency, Data Transparency, Stack Transparency, and Address Space Transparency, We have seen many cases of applications that access invalid memory natively, handle the exception, and carry on. Without Error Transparency such applications would not work properly under DynamoRIO.</p>
<dl class="section user"><dt>Timing Transparency</dt><dd></dd></dl>
<p>We would like to make it impossible for the application to determine whether it is executing inside of DynamoRIO. However, this may not be attainable for some aspects of execution, such as the exact timing of certain operations. This brings efficiency into the transparency equation.</p>
<p>Changing the timing of multi-threaded applications can uncover behavior that does not normally happen natively. We have encountered race conditions while executing under DynamoRIO that are difficult to reproduce outside of our system. These are not strictly speaking transparency violations, as the errors <em>could</em> have occurred without us, but are best avoided.</p>
<dl class="section user"><dt>Debugging Transparency</dt><dd></dd></dl>
<p>A debugger should be able to attach to a process under DynamoRIO's control just like it would natively. Previously discussed transparency issues overlap with Debugging Transparency. Stack Transparency and Data Transparency ensure that callstacks and application memory show up correctly. However, DynamoRIO can't entirely hide the fact that the application is running out of a code cache from the debugger. The debugger will see the wrong eip value when breaking in and execution break points will not work correctly (and in fact can lead to corruption of the DynamoRIO code cache). Debugging Tools for Windows and <code>gdb</code> are known to work with DynamoRIO with the exception of the issues noted above.</p>
<h1><a class="anchor" id="sec_trans_alertable"></a>
Alertable System Calls</h1>
<p>On Windows, DynamoRIO does not support a client making alertable system calls. See <a class="el" href="using.html#sec_alertable">Avoid Alertable System Calls</a> for more information. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="adr__ir__utils_8h_html_aa23665c11b7d79a29ea185113d07944f"><div class="ttname"><a href="dr__ir__utils_8h.html#aa23665c11b7d79a29ea185113d07944f">dr_insert_save_fpstate</a></div><div class="ttdeci">DR_API void dr_insert_save_fpstate(void *drcontext, instrlist_t *ilist, instr_t *where, opnd_t buf)</div></div>
<div class="ttc" id="adr__proc_8h_html_aacb849daecc3021e451d9441b26cc814"><div class="ttname"><a href="dr__proc_8h.html#aacb849daecc3021e451d9441b26cc814">proc_restore_fpstate</a></div><div class="ttdeci">DR_API void proc_restore_fpstate(byte *buf)</div></div>
<div class="ttc" id="adr__proc_8h_html_a48ca3205c37d6e41d007ac54a1d60e6a"><div class="ttname"><a href="dr__proc_8h.html#a48ca3205c37d6e41d007ac54a1d60e6a">proc_save_fpstate</a></div><div class="ttdeci">DR_API size_t proc_save_fpstate(byte *buf)</div></div>
<div class="ttc" id="adr__ir__utils_8h_html_a74016eacf3a9cfc20a93a9ac0bca9c59"><div class="ttname"><a href="dr__ir__utils_8h.html#a74016eacf3a9cfc20a93a9ac0bca9c59">dr_insert_restore_fpstate</a></div><div class="ttdeci">DR_API void dr_insert_restore_fpstate(void *drcontext, instrlist_t *ilist, instr_t *where, opnd_t buf)</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
