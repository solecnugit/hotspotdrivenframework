---
title: "Register Management"
layout: default
permalink: /page_drreg.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Register Management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <code>drreg</code> DynamoRIO Register Management Extension is a mediator for selecting, preserving, and using registers among multiple instrumentation components. The interface is meant to be used in concert with the <code>drmgr</code> instrumentation pass scheme. The results are most efficient when used in the <code>drmgr</code> instrumentation insertion phase. Use outside of the insertion phase, such as during <code>drmgr's</code> instrumentation-to-instrumentation transformation phase, or use outside of <code>drmgr</code> entirely, is supported, but duplicate spills and restores may not be optimized away. Also, for non-insertion phases, the responsibility to restore a spilled app value before certain instructions like an app read or a label with the note <a class="el" href="dr__defines_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a775cd05e3af0ab56c47dba3dabc32758">DR_NOTE_ANNOTATION</a>, and to re-spill the app value after an app write, lies with the user; in the insertion phase, this is done automatically, but it needs to be done manually in non-insertion phases. When using drreg to reserve registers in multiple phases (like app2app or instru2instru in addition to the insertion phase), it is important to call <a class="el" href="group__drreg.html#ga7910ab166b0d698c11964a7b89d90faf">drreg_set_bb_properties()</a> with <a class="el" href="group__drreg.html#gga9aa35aebc3d4f0f41cba66bfcde82a00a2d1537112f577f6e8943463069b523d6">DRREG_HANDLE_MULTI_PHASE_SLOT_RESERVATIONS</a> to enable logic that avoids conflicts with spill slots used by previous phases. This may have some performance cost, so we do not turn it on by default. Using this option also makes spill slots used in prior phases less available in future phases; the current logic skips over a slot if there's a usage found anywhere later in the bb added by any previous phase. So it requires additional spill slots as well.</p>
<p>Note that DR provides other APIs to save or restore regs, like <code><a class="el" href="dr__ir__utils_8h.html#ae8479716f08bbbb36d7fd27cfbbc0743">dr_save_reg()</a></code> and <code><a class="el" href="dr__ir__utils_8h.html#a97e9767e1ff0f426b552a5f18c528ced">dr_restore_reg()</a></code>, and the corresponding <code><a class="el" href="dr__ir__utils_8h.html#a6fdc15ea04e8d17fa537832acf274d9c">dr_read_saved_reg()</a></code> and <code><a class="el" href="dr__ir__utils_8h.html#a178b4afb7bc059afbb92e9bee3572ca0">dr_write_saved_reg()</a></code>. They use DR spill slots. drreg may also use DR spill slots if not given enough dedicated slots via <a class="el" href="struct__drreg__options__t.html#a6bbbd6b9f361d671cec4c6bd0142259d">drreg_options_t.num_spill_slots</a>. It is unsafe to mix usages of drreg and these direct APIs as it may cause conflicts in slot usages within the same client or with other clients/libraries. Therefore, all cooperating client components should use drreg. Also, clients should make sure to request sufficient dedicated slots from drreg. See documentation of <a class="el" href="struct__drreg__options__t.html#a6bbbd6b9f361d671cec4c6bd0142259d">drreg_options_t.num_spill_slots</a> for more details.</p>
<ul>
<li><a class="el" href="page_drreg.html#sec_drreg_setup">Setup</a></li>
<li><a class="el" href="page_drreg.html#sec_drreg_usage">Usage</a></li>
<li><a class="el" href="page_drreg.html#sec_drreg_app_values">Application Values</a></li>
<li><a class="el" href="page_drreg.html#sec_drreg_linear">Linear Control Flow</a></li>
</ul>
<h1><a class="anchor" id="sec_drreg_setup"></a>
Setup</h1>
<p>To use <code>drreg</code> with your client simply include this line in your client's <code>CMakeLists.txt</code> file:</p>
<div class="fragment"><div class="line">use_DynamoRIO_extension(clientname drreg) </div>
</div><!-- fragment --><p>That will automatically set up the include path and library dependence.</p>
<p>The initialization routine <code><a class="el" href="group__drreg.html#ga6656df86f1a73bdf739eedaba7220c46">drreg_init()</a></code> must be called prior to any of the other routines. Additional calls to <a class="el" href="group__drreg.html#ga6656df86f1a73bdf739eedaba7220c46">drreg_init()</a> are allowed (so long as they are paired with corresponding calls to <a class="el" href="group__drreg.html#gac43a098af5baddf9190a332550d50f85">drreg_exit()</a>). The option fields are combined from multiple calls as described in the documentation for each field. Typically the end-user tool itself specifies these options, with most other library components not directly interacting with drreg (libraries often take in scratch registers from the caller for most of their operations).</p>
<h1><a class="anchor" id="sec_drreg_usage"></a>
Usage</h1>
<p>The <code>drreg</code> API is based on a reservation model. Each general-purpose register may be reserved for a period of time and then unreserved. The process of reserving spills the application value, if necessary. A reservation implies exclusive access to that register. Reservations may extend across application instructions, in which case <code>drreg</code> will automatically restore or re-spill application values, when the intervening application instruction reads or writes that register, while still preserving the client's value in that register for use after the application instruction. Reservations may not extend beyond the end of a basic block.</p>
<h1><a class="anchor" id="sec_drreg_app_values"></a>
Application Values</h1>
<p><code>drreg</code> assumes that only application instructions need to read application values. <code>drreg</code> assumes that it is safe to wait as long as possible to restore a spilled application value that is no longer reserved. If a client is inserting instrumentation that reads application values, or is using a library routine that does the same, the client needs to tell <code>drreg</code> to restore the needed application registers. This can be done with <a class="el" href="group__drreg.html#gaf3a0543b8c49f5bb7af6cae384af34d2">drreg_restore_app_values()</a> or with <a class="el" href="group__drreg.html#ga52ef72f8179e3a1eff9f74cab9d733c4">drreg_get_app_value()</a>. This essentially acts as a "barrier" to lazy restoring.</p>
<p>Clean calls that read the application context (via <a class="el" href="dr__ir__utils_8h.html#a9e348b2596b8750ce3fad234ab022ced">dr_get_mcontext()</a>) can have a barrier auto-inserted by passing <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212a76efe3cf7cffc2bf14da79133bc2e5c3">DR_CLEANCALL_READS_APP_CONTEXT</a> to <a class="el" href="dr__ir__utils_8h.html#a175c7c2531aa70017d2fb020f93e374f">dr_insert_clean_call_ex()</a> or dr_insert_clean_call_ex_varg(). Similarly, clean calls that modify the application context (via <a class="el" href="dr__ir__utils_8h.html#ac4bfa7fc3f9d4adb0857675bec2712a2">dr_set_mcontext()</a>) should pass <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab0fb37c5cbbd2c2cd9ebd9eb5e53f23e">DR_CLEANCALL_WRITES_APP_CONTEXT</a> to ensure that <code>drreg</code> updates the new application values. There can be failures to restore application values at points in an instruction list where a register is considered dead and its value is not available (if <a class="el" href="struct__drreg__options__t.html#a3f7789278b96170f6b9345c6bec730b8">drreg_options_t.conservative</a> is set to false), but it is assumed that the value is in fact dead and does not matter.</p>
<p>If a clean call is only conditionally executed due to inserted tool control flow, the flag <a class="el" href="dr__defines_8h.html#af1b1bc23c42ffb7452568176b09b1212ab3ed3f85123fad82c4377cebaa2c36ed">DR_CLEANCALL_MULTIPATH</a> can be passed in addition to the read or write flag. This results in stateless restores. However, tool values will be clobbered by those restores. If control flow and clean call context access is used with registers holding tool values across the clean call, manual restoration may be required rather than passing any of these automated flags.</p>
<h1><a class="anchor" id="sec_drreg_linear"></a>
Linear Control Flow</h1>
<p>The <code>drreg</code> API was designed for linear control flow. The API assumes that it can safely wait to restore an unreserved scratch register across application instructions. If a client inserts internal control flow inside a basic block that crosses application instructions, and the client is not explicitly ensuring that each forward jump contains the same set of saved scratch registers at its source and target (typically done by saving all scratch registers that will be needed inside control flow prior to any forward branches), the client should tell <code>drreg</code> to disable its optimizations. This is done by calling <a class="el" href="group__drreg.html#ga7910ab166b0d698c11964a7b89d90faf">drreg_set_bb_properties()</a> and passing <a class="el" href="group__drreg.html#gga9aa35aebc3d4f0f41cba66bfcde82a00a7480b21f4a67dd853d857271f4eaf058">DRREG_CONTAINS_SPANNING_CONTROL_FLOW</a> either prior to the drmgr insertion phase or as early as possible in the insertion phase. Setting this property causes application instructions to become barriers to spilled scratch registers that have been unreserved but have not yet been lazily restored. Such scratch registers are then restored prior to each application instruction. <code>drreg</code> will still collapse adjacent spill+restore pairs for the same app instr.</p>
<p>For control flow added during the app2app phase (such as by <a class="el" href="group__drutil.html#gae38961d42fc285d7f9034c4b02690cae">drutil_expand_rep_string()</a>), <code>drreg</code> is able to identify and act on its own. Normally, drreg disables optimizations if it sees any kind of internal control flow (viz., a branch with an <a class="el" href="structinstr__t.html">instr_t</a> target) while examining code during the analysis phase. If the client is certain that all app2app internal control flow that it and any libraries it uses either do not cross application instructions or satisfy the property that each forward jump contains the same set of saved scratch registers at its source as at its target (typically done by saving all scratch registers needed inside control flow prior to any forward branches), then the client can call <a class="el" href="group__drreg.html#ga7910ab166b0d698c11964a7b89d90faf">drreg_set_bb_properties()</a> and pass <a class="el" href="group__drreg.html#gga9aa35aebc3d4f0f41cba66bfcde82a00a7bbb7c0168068bd904f612b89b4c5dc9">DRREG_IGNORE_CONTROL_FLOW</a> in order to enable full lazy restores by <code>drreg</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
