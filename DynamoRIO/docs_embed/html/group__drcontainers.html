---
title: "Container Data Structures"
layout: default
permalink: /group__drcontainers.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Container Data Structures</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drvector__t.html">_drvector_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaeaba87af31694a825496218053177d64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaeaba87af31694a825496218053177d64">DRTABLE_INVALID_INDEX</a>&#160;&#160;&#160;((ptr_uint_t)-1)</td></tr>
<tr class="separator:gaeaba87af31694a825496218053177d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad6c70a83ab635d96376710bffe4e4ced"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drvector__t.html">_drvector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a></td></tr>
<tr class="separator:gad6c70a83ab635d96376710bffe4e4ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad856384ed5ad3b1a1c42e5095d7432b8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gad856384ed5ad3b1a1c42e5095d7432b8">hashtable_config_t</a></td></tr>
<tr class="separator:gad856384ed5ad3b1a1c42e5095d7432b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabdc8e2396ab8607a7e4c1e5f05c588c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gabdc8e2396ab8607a7e4c1e5f05c588c3">drtable_flags_t</a> { <br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggabdc8e2396ab8607a7e4c1e5f05c588c3a8a428f6ca9cdbd75e3f9807d8e03379f">DRTABLE_MEM_REACHABLE</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggabdc8e2396ab8607a7e4c1e5f05c588c3adc74fb8cb16fc3a8a9fd8f898ee05d98">DRTABLE_MEM_32BIT</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggabdc8e2396ab8607a7e4c1e5f05c588c3a3a762298e3f0d70895d7ba6602e6cfbe">DRTABLE_ALLOC_COMPACT</a> = 0x4
<br />
 }</td></tr>
<tr class="separator:gabdc8e2396ab8607a7e4c1e5f05c588c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cde78f27c3374749c462a5d58a5e38e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38ea7e83c8ad190fd19419c301ace3bcbe2e">HASH_INTPTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38ea3a57810af6552f1efcda7a6abddbe92a">HASH_STRING</a>, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38eae0b0e4c68e2bab129d1d2a6ff43d44d4">HASH_STRING_NOCASE</a>, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38eaa90b8cffea02e8d64d001982ddb0c310">HASH_CUSTOM</a>
<br />
 }</td></tr>
<tr class="separator:ga2cde78f27c3374749c462a5d58a5e38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d7584cf61da0c9d25d40a2cbdbb4f5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> { <br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5ad21f75ecfeda6b17850ce1f37cbfbfe3">DR_HASHPERS_PAYLOAD_IS_POINTER</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5a281f8669fb41cf530d3e9b5bcefeee1a">DR_HASHPERS_CLONE_PAYLOAD</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5a01b2e63a35d528e3aa0d1d7b94acc82d">DR_HASHPERS_REBASE_KEY</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5acbb5b7692eb0abd2630636398a7c68b7">DR_HASHPERS_ONLY_IN_RANGE</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5aaf682665078c712befd63824f03dbd7c">DR_HASHPERS_ONLY_PERSISTED</a> = 0x0010
<br />
 }</td></tr>
<tr class="separator:gae4d7584cf61da0c9d25d40a2cbdbb4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2eac73999ae64ce7dab8617e7c3607dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2eac73999ae64ce7dab8617e7c3607dd">drtable_create</a> (ptr_uint_t capacity, size_t entry_size, uint flags, bool synch, void(*free_entry_func)(ptr_uint_t idx, void *entry, void *user_data))</td></tr>
<tr class="separator:ga2eac73999ae64ce7dab8617e7c3607dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b426a61810d4725391304f51efd423c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga1b426a61810d4725391304f51efd423c">drtable_alloc</a> (void *tab, ptr_uint_t num_entries, ptr_uint_t *idx_ptr)</td></tr>
<tr class="separator:ga1b426a61810d4725391304f51efd423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72aa8dc1faa57b8ac88cd8ead4ed006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab72aa8dc1faa57b8ac88cd8ead4ed006">drtable_destroy</a> (void *tab, void *user_data)</td></tr>
<tr class="separator:gab72aa8dc1faa57b8ac88cd8ead4ed006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1582acfe56f0ad7d8897e314aeea61fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga1582acfe56f0ad7d8897e314aeea61fd">drtable_iterate</a> (void *tab, void *iter_data, bool(*iter_func)(ptr_uint_t id, void *, void *))</td></tr>
<tr class="separator:ga1582acfe56f0ad7d8897e314aeea61fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6dc346bbda6ed02e1065974242e1d4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaed6dc346bbda6ed02e1065974242e1d4">drtable_get_entry</a> (void *tab, ptr_uint_t idx)</td></tr>
<tr class="separator:gaed6dc346bbda6ed02e1065974242e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061cb4a1744b6f075a515ed43ba166fb"><td class="memItemLeft" align="right" valign="top">ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga061cb4a1744b6f075a515ed43ba166fb">drtable_get_index</a> (void *tab, void *ptr)</td></tr>
<tr class="separator:ga061cb4a1744b6f075a515ed43ba166fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad164ad428e8e5d8927cd6ff0bb5566b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gad164ad428e8e5d8927cd6ff0bb5566b5">drtable_lock</a> (void *tab)</td></tr>
<tr class="separator:gad164ad428e8e5d8927cd6ff0bb5566b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138f40390422527895eda77fb2d2dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab138f40390422527895eda77fb2d2dbb">drtable_unlock</a> (void *tab)</td></tr>
<tr class="separator:gab138f40390422527895eda77fb2d2dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebd56f50630fd8e60c0a26037f8c35a"><td class="memItemLeft" align="right" valign="top">ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga9ebd56f50630fd8e60c0a26037f8c35a">drtable_num_entries</a> (void *tab)</td></tr>
<tr class="separator:ga9ebd56f50630fd8e60c0a26037f8c35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3d018db60aa066b151220ff9202d54"><td class="memItemLeft" align="right" valign="top">ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaca3d018db60aa066b151220ff9202d54">drtable_dump_entries</a> (void *tab, file_t log)</td></tr>
<tr class="separator:gaca3d018db60aa066b151220ff9202d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5206874469dc2551dad9e8f375e87df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gae5206874469dc2551dad9e8f375e87df">drvector_init</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec, uint initial_capacity, bool synch, void(*free_data_func)(void *))</td></tr>
<tr class="separator:gae5206874469dc2551dad9e8f375e87df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa578776ea720fb04c87ac04181d89f4e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaa578776ea720fb04c87ac04181d89f4e">drvector_get_entry</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec, uint idx)</td></tr>
<tr class="separator:gaa578776ea720fb04c87ac04181d89f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70494a642307dd41ad8b6a754fcea9c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga70494a642307dd41ad8b6a754fcea9c8">drvector_set_entry</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec, uint idx, void *data)</td></tr>
<tr class="separator:ga70494a642307dd41ad8b6a754fcea9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga380b542d2b8b997ded501df7f54b6919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga380b542d2b8b997ded501df7f54b6919">drvector_append</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec, void *data)</td></tr>
<tr class="separator:ga380b542d2b8b997ded501df7f54b6919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e5949b592508c61e35ec14bfa731d62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2e5949b592508c61e35ec14bfa731d62">drvector_delete</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec)</td></tr>
<tr class="separator:ga2e5949b592508c61e35ec14bfa731d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1b3d3080e42bc98cddc75d675cd786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gacf1b3d3080e42bc98cddc75d675cd786">drvector_lock</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec)</td></tr>
<tr class="separator:gacf1b3d3080e42bc98cddc75d675cd786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752060ab72ce4d597fed7684332bba5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga752060ab72ce4d597fed7684332bba5b">drvector_unlock</a> (<a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *vec)</td></tr>
<tr class="separator:ga752060ab72ce4d597fed7684332bba5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab341e9839c6cbd89a5a442df73468f5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab341e9839c6cbd89a5a442df73468f5f">stri_eq</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:gab341e9839c6cbd89a5a442df73468f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf202d20209b04c9ea9fd0657f3cfccc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaf202d20209b04c9ea9fd0657f3cfccc6">hashtable_global_config</a> (void *(*alloc_func)(size_t), void(*free_func)(void *, size_t), void(*assert_fail_func)(const char *))</td></tr>
<tr class="separator:gaf202d20209b04c9ea9fd0657f3cfccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d69f3a60f5ba9c75698649465be695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga96d69f3a60f5ba9c75698649465be695">hashtable_init</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup)</td></tr>
<tr class="separator:ga96d69f3a60f5ba9c75698649465be695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307d17165381371418414308b3eed803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga307d17165381371418414308b3eed803">hashtable_init_ex</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup, bool synch, void(*free_payload_func)(void *), uint(*hash_key_func)(void *), bool(*cmp_key_func)(void *, void *))</td></tr>
<tr class="separator:ga307d17165381371418414308b3eed803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9225a8b532a579db4f193b2a236686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2e9225a8b532a579db4f193b2a236686">hashtable_configure</a> (hashtable_t *table, <a class="el" href="group__drcontainers.html#gad856384ed5ad3b1a1c42e5095d7432b8">hashtable_config_t</a> *config)</td></tr>
<tr class="separator:ga2e9225a8b532a579db4f193b2a236686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6af018f2bb18648861e76bc0fdec96e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaa6af018f2bb18648861e76bc0fdec96e">hashtable_lookup</a> (hashtable_t *table, void *key)</td></tr>
<tr class="separator:gaa6af018f2bb18648861e76bc0fdec96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42cb0b8a85c6b4cdba6ee7b984aeff25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga42cb0b8a85c6b4cdba6ee7b984aeff25">hashtable_add</a> (hashtable_t *table, void *key, void *payload)</td></tr>
<tr class="separator:ga42cb0b8a85c6b4cdba6ee7b984aeff25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d443ee70d3fd35d853b9697f999cbf7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga3d443ee70d3fd35d853b9697f999cbf7">hashtable_add_replace</a> (hashtable_t *table, void *key, void *payload)</td></tr>
<tr class="separator:ga3d443ee70d3fd35d853b9697f999cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8972b42e34447e229489ab120271dbfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga8972b42e34447e229489ab120271dbfd">hashtable_remove</a> (hashtable_t *table, void *key)</td></tr>
<tr class="separator:ga8972b42e34447e229489ab120271dbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9699afdfaab140f2e98b7783a51b19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga4a9699afdfaab140f2e98b7783a51b19">hashtable_remove_range</a> (hashtable_t *table, void *start, void *end)</td></tr>
<tr class="separator:ga4a9699afdfaab140f2e98b7783a51b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01abdf4a47a2603aca94ab3f5be14c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga01abdf4a47a2603aca94ab3f5be14c98">hashtable_apply_to_all_payloads</a> (hashtable_t *table, void(*apply_func)(void *payload))</td></tr>
<tr class="separator:ga01abdf4a47a2603aca94ab3f5be14c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d3119a99127a7d18441bbecc868699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga82d3119a99127a7d18441bbecc868699">hashtable_apply_to_all_payloads_user_data</a> (hashtable_t *table, void(*apply_func)(void *payload, void *user_data), void *user_data)</td></tr>
<tr class="separator:ga82d3119a99127a7d18441bbecc868699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bcb10d265f6005bbcef89129ad58548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2bcb10d265f6005bbcef89129ad58548">hashtable_clear</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga2bcb10d265f6005bbcef89129ad58548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e402d49c64df6809c82483a8ddd6770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga9e402d49c64df6809c82483a8ddd6770">hashtable_delete</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga9e402d49c64df6809c82483a8ddd6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ba198cad4e146607e8a07db005b514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga98ba198cad4e146607e8a07db005b514">hashtable_lock</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga98ba198cad4e146607e8a07db005b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7f9e88180c79d080113e2bec858dbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga8d7f9e88180c79d080113e2bec858dbf">hashtable_unlock</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga8d7f9e88180c79d080113e2bec858dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15c2ca65b95597ff2311f1040f1be53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gac15c2ca65b95597ff2311f1040f1be53">hashtable_lock_self_owns</a> (hashtable_t *table)</td></tr>
<tr class="separator:gac15c2ca65b95597ff2311f1040f1be53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d52ff455ac9bab9ef5ffe49586e904"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size</a> (void *drcontext, hashtable_t *table, size_t entry_size, void *perscxt, <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> flags)</td></tr>
<tr class="separator:gab3d52ff455ac9bab9ef5ffe49586e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012f1fb1127c60d90bd76d662c3dbf4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist</a> (void *drcontext, hashtable_t *table, size_t entry_size, file_t fd, void *perscxt, <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> flags)</td></tr>
<tr class="separator:ga012f1fb1127c60d90bd76d662c3dbf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5857998e61b2477997fad25adf71580b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect</a> (void *drcontext, byte **map, hashtable_t *table, size_t entry_size, void *perscxt, <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> flags, bool(*process_payload)(void *key, void *payload, ptr_int_t shift))</td></tr>
<tr class="separator:ga5857998e61b2477997fad25adf71580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaeaba87af31694a825496218053177d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaba87af31694a825496218053177d64">&#9670;&nbsp;</a></span>DRTABLE_INVALID_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRTABLE_INVALID_INDEX&#160;&#160;&#160;((ptr_uint_t)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid index of drtable </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad6c70a83ab635d96376710bffe4e4ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c70a83ab635d96376710bffe4e4ced">&#9670;&nbsp;</a></span>drvector_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drvector__t.html">_drvector_t</a> <a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The storage for a vector. </p>

</div>
</div>
<a id="gad856384ed5ad3b1a1c42e5095d7432b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad856384ed5ad3b1a1c42e5095d7432b8">&#9670;&nbsp;</a></span>hashtable_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a> <a class="el" href="group__drcontainers.html#gad856384ed5ad3b1a1c42e5095d7432b8">hashtable_config_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration parameters for a hashtable. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gabdc8e2396ab8607a7e4c1e5f05c588c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc8e2396ab8607a7e4c1e5f05c588c3">&#9670;&nbsp;</a></span>drtable_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#gabdc8e2396ab8607a7e4c1e5f05c588c3">drtable_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used for drtable_create </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabdc8e2396ab8607a7e4c1e5f05c588c3a8a428f6ca9cdbd75e3f9807d8e03379f"></a>DRTABLE_MEM_REACHABLE&#160;</td><td class="fielddoc"><p>allocated table entries must be reachable from code cache </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabdc8e2396ab8607a7e4c1e5f05c588c3adc74fb8cb16fc3a8a9fd8f898ee05d98"></a>DRTABLE_MEM_32BIT&#160;</td><td class="fielddoc"><p>Allocates table entries from the addresss space that can be converted to a 32-bit int. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabdc8e2396ab8607a7e4c1e5f05c588c3a3a762298e3f0d70895d7ba6602e6cfbe"></a>DRTABLE_ALLOC_COMPACT&#160;</td><td class="fielddoc"><p>Allocates table entries as compactly as possible, which may return indics in a random order. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2cde78f27c3374749c462a5d58a5e38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cde78f27c3374749c462a5d58a5e38e">&#9670;&nbsp;</a></span>hash_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of hash key </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2cde78f27c3374749c462a5d58a5e38ea7e83c8ad190fd19419c301ace3bcbe2e"></a>HASH_INTPTR&#160;</td><td class="fielddoc"><p>A pointer-sized integer or pointer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2cde78f27c3374749c462a5d58a5e38ea3a57810af6552f1efcda7a6abddbe92a"></a>HASH_STRING&#160;</td><td class="fielddoc"><p>A case-sensitive string </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2cde78f27c3374749c462a5d58a5e38eae0b0e4c68e2bab129d1d2a6ff43d44d4"></a>HASH_STRING_NOCASE&#160;</td><td class="fielddoc"><p>A case-insensitive string </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2cde78f27c3374749c462a5d58a5e38eaa90b8cffea02e8d64d001982ddb0c310"></a>HASH_CUSTOM&#160;</td><td class="fielddoc"><p>A custom key. Hash and compare operations must be provided in <a class="el" href="group__drcontainers.html#ga307d17165381371418414308b3eed803">hashtable_init_ex()</a>. The hash operation can return a full uint, as its result will be truncated via a mod of the hash key bit size. This allows for resizing the table without changing the hash operation. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae4d7584cf61da0c9d25d40a2cbdbb4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4d7584cf61da0c9d25d40a2cbdbb4f5">&#9670;&nbsp;</a></span>hasthable_persist_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to control hashtable persistence </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5ad21f75ecfeda6b17850ce1f37cbfbfe3"></a>DR_HASHPERS_PAYLOAD_IS_POINTER&#160;</td><td class="fielddoc"><p>Valid for <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> and <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a> and the same value must be passed to both. Treats payloads as pointers to allocated memory. By default payloads are treated as inlined values if this flag is not set. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5a281f8669fb41cf530d3e9b5bcefeee1a"></a>DR_HASHPERS_CLONE_PAYLOAD&#160;</td><td class="fielddoc"><p>Valid for <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a>. Only applies if DR_HASHPERS_KEY_IS_POINTER. Performs a shallow clone of the payload upon resurrection. If this flag is not set, the payloads will remain pointing into the mapped file. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5a01b2e63a35d528e3aa0d1d7b94acc82d"></a>DR_HASHPERS_REBASE_KEY&#160;</td><td class="fielddoc"><p>Valid for <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a>, <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>, and <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a>, and the same value must be passed to all. Only applies if keys are of type HASH_INTPTR. Adjusts each key by the difference in the persist-time start address of the persisted code region and the resurrected start address. The value of this flag must match across all three calls <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a>, <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>, and <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5acbb5b7692eb0abd2630636398a7c68b7"></a>DR_HASHPERS_ONLY_IN_RANGE&#160;</td><td class="fielddoc"><p>Valid for <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> and the same value must be passed to both. Only applies if keys are of type HASH_INTPTR. Only persists entries whose key is in the address range being persisted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5aaf682665078c712befd63824f03dbd7c"></a>DR_HASHPERS_ONLY_PERSISTED&#160;</td><td class="fielddoc"><p>Valid for <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> and the same value must be passed to both. Only applies if keys are of type HASH_INTPTR. Only persists entries for which <a class="el" href="dr__events_8h.html#a8e02ed6af55d443db6f84778002cda78">dr_fragment_persistable()</a> returns true. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1b426a61810d4725391304f51efd423c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b426a61810d4725391304f51efd423c">&#9670;&nbsp;</a></span>drtable_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drtable_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>num_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t *&#160;</td>
          <td class="paramname"><em>idx_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory for an array of <code>num_entries</code> table entries, and returns a pointer to the allocated memory. Returns NULL if fails. If <code>idx_ptr</code> is not NULL, the index for the first entry is returned in <code>idx_ptr</code>, and all the entries from the same allocation can be referred to as index + n. </p>

</div>
</div>
<a id="ga2eac73999ae64ce7dab8617e7c3607dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eac73999ae64ce7dab8617e7c3607dd">&#9670;&nbsp;</a></span>drtable_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drtable_create </td>
          <td>(</td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(ptr_uint_t idx, void *entry, void *user_data)&#160;</td>
          <td class="paramname"><em>free_entry_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a drtable with the given parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The approximate number of entries for the table. The capacity is only a suggestion for better memory usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry, which should be greater than 0 and smaller than USHRT_MAX (65535). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The flags to specify the features of the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synch</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the table's lock is initialized and can be used via <a class="el" href="group__drcontainers.html#gad164ad428e8e5d8927cd6ff0bb5566b5">drtable_lock()</a> and <a class="el" href="group__drcontainers.html#gab138f40390422527895eda77fb2d2dbb">drtable_unlock()</a>, allowing the caller to extend synchronization beyond just the operation in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_entry_func</td><td>The callback for freeing each table entry. Leave it NULL if no callback is needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab72aa8dc1faa57b8ac88cd8ead4ed006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab72aa8dc1faa57b8ac88cd8ead4ed006">&#9670;&nbsp;</a></span>drtable_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all storage for the table. The <code>user_data</code> is passed to each <code>free_entry_func</code> if specified. </p>

</div>
</div>
<a id="gaca3d018db60aa066b151220ff9202d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca3d018db60aa066b151220ff9202d54">&#9670;&nbsp;</a></span>drtable_dump_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptr_uint_t drtable_dump_entries </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dumps all the table entries as an array into a file in binary format. There is no header add, so the user should add one if so desired. Returns the number of entries dumped. </p>

</div>
</div>
<a id="gaed6dc346bbda6ed02e1065974242e1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed6dc346bbda6ed02e1065974242e1d4">&#9670;&nbsp;</a></span>drtable_get_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drtable_get_entry </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the entry at index <code>idx</code>. Returns NULL if the entry for <code>idx</code> is not allocated. </p>

</div>
</div>
<a id="ga061cb4a1744b6f075a515ed43ba166fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga061cb4a1744b6f075a515ed43ba166fb">&#9670;&nbsp;</a></span>drtable_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptr_uint_t drtable_get_index </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an index to the entry pointed at by <code>ptr</code>. Returns DRTABLE_INVALID_INDEX if <code>ptr</code> does not point to any allocated entries. </p>

</div>
</div>
<a id="ga1582acfe56f0ad7d8897e314aeea61fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1582acfe56f0ad7d8897e314aeea61fd">&#9670;&nbsp;</a></span>drtable_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_iterate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iter_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ptr_uint_t id, void *, void *)&#160;</td>
          <td class="paramname"><em>iter_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over entries in the table and call the callback function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tab</td><td>The drtable to be operated on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_data</td><td>Iteration data passed to <code>iter_func</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_func</td><td>The callback for iterating each table entry. Returns false to stop iterating. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad164ad428e8e5d8927cd6ff0bb5566b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad164ad428e8e5d8927cd6ff0bb5566b5">&#9670;&nbsp;</a></span>drtable_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the table lock. </p>

</div>
</div>
<a id="ga9ebd56f50630fd8e60c0a26037f8c35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ebd56f50630fd8e60c0a26037f8c35a">&#9670;&nbsp;</a></span>drtable_num_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptr_uint_t drtable_num_entries </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of entries in the table. </p>

</div>
</div>
<a id="gab138f40390422527895eda77fb2d2dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab138f40390422527895eda77fb2d2dbb">&#9670;&nbsp;</a></span>drtable_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the table lock. </p>

</div>
</div>
<a id="ga380b542d2b8b997ded501df7f54b6919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga380b542d2b8b997ded501df7f54b6919">&#9670;&nbsp;</a></span>drvector_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new entry to the end of the vector, resizing it if necessary. If <a class="el" href="group__drcontainers.html#ga70494a642307dd41ad8b6a754fcea9c8">drvector_set_entry()</a> has been called, this will add to the index beyond the last index passed to <a class="el" href="group__drcontainers.html#ga70494a642307dd41ad8b6a754fcea9c8">drvector_set_entry()</a>. </p>

</div>
</div>
<a id="ga2e5949b592508c61e35ec14bfa731d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e5949b592508c61e35ec14bfa731d62">&#9670;&nbsp;</a></span>drvector_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all storage for the vector. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a id="gaa578776ea720fb04c87ac04181d89f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa578776ea720fb04c87ac04181d89f4e">&#9670;&nbsp;</a></span>drvector_get_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drvector_get_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the entry at index <code>idx</code>. For an unsychronized table, the caller is free to directly access the <code>array</code> field of <code>vec</code>. </p>

</div>
</div>
<a id="gae5206874469dc2551dad9e8f375e87df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5206874469dc2551dad9e8f375e87df">&#9670;&nbsp;</a></span>drvector_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>initial_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_data_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a drvector with the given parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>The vector to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_capacity</td><td>The initial number of entries allocated for the vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synch</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the vector's lock is initialized and can be used via vector_lock() and vector_unlock(), allowing the caller to extend synchronization beyond just the operation in question, to include accessing a looked-up payload, e.g. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_data_func</td><td>A callback for freeing each data item. Leave it NULL if no callback is needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf1b3d3080e42bc98cddc75d675cd786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf1b3d3080e42bc98cddc75d675cd786">&#9670;&nbsp;</a></span>drvector_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drvector_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the vector lock. </p>

</div>
</div>
<a id="ga70494a642307dd41ad8b6a754fcea9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70494a642307dd41ad8b6a754fcea9c8">&#9670;&nbsp;</a></span>drvector_set_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_set_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the entry at index <code>idx</code> to <code>data</code>. For an unsychronized table, the caller is free to directly set the <code>array</code> field of <code>vec</code>. Entries in between the last set index and <code>idx</code> are left uninitialized. Returns whether successful. </p>

</div>
</div>
<a id="ga752060ab72ce4d597fed7684332bba5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga752060ab72ce4d597fed7684332bba5b">&#9670;&nbsp;</a></span>drvector_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drvector_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad6c70a83ab635d96376710bffe4e4ced">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the vector lock. </p>

</div>
</div>
<a id="ga42cb0b8a85c6b4cdba6ee7b984aeff25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42cb0b8a85c6b4cdba6ee7b984aeff25">&#9670;&nbsp;</a></span>hashtable_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_add </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new entry. Returns false if an entry for <code>key</code> already exists. </p><dl class="section note"><dt>Note</dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div>
<a id="ga3d443ee70d3fd35d853b9697f999cbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d443ee70d3fd35d853b9697f999cbf7">&#9670;&nbsp;</a></span>hashtable_add_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_add_replace </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new entry, replacing an existing entry if any. Returns the old payload, or NULL if there was no existing entry. </p><dl class="section note"><dt>Note</dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div>
<a id="ga01abdf4a47a2603aca94ab3f5be14c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01abdf4a47a2603aca94ab3f5be14c98">&#9670;&nbsp;</a></span>hashtable_apply_to_all_payloads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_apply_to_all_payloads </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *payload)&#160;</td>
          <td class="paramname"><em>apply_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <code>apply_func</code> for each payload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The hashtable to apply the function. </td></tr>
    <tr><td class="paramname">apply_func</td><td>A pointer to a function that is called for all payloads stored in the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82d3119a99127a7d18441bbecc868699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82d3119a99127a7d18441bbecc868699">&#9670;&nbsp;</a></span>hashtable_apply_to_all_payloads_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_apply_to_all_payloads_user_data </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *payload, void *user_data)&#160;</td>
          <td class="paramname"><em>apply_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <code>apply_func</code> for each payload with user data. Similar to <a class="el" href="group__drcontainers.html#ga01abdf4a47a2603aca94ab3f5be14c98">hashtable_apply_to_all_payloads()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The hashtable to apply the function. </td></tr>
    <tr><td class="paramname">apply_func</td><td>A pointer to a function that is called for all payloads stored in the map. It also takes user data as a parameter. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data that is available when iterating through payloads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bcb10d265f6005bbcef89129ad58548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bcb10d265f6005bbcef89129ad58548">&#9670;&nbsp;</a></span>hashtable_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_clear </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all entries from the table. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a id="ga2e9225a8b532a579db4f193b2a236686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e9225a8b532a579db4f193b2a236686">&#9670;&nbsp;</a></span>hashtable_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_configure </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gad856384ed5ad3b1a1c42e5095d7432b8">hashtable_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures optional parameters of hashtable operation. </p>

</div>
</div>
<a id="ga9e402d49c64df6809c82483a8ddd6770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e402d49c64df6809c82483a8ddd6770">&#9670;&nbsp;</a></span>hashtable_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_delete </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all storage for the table, including all entries and the table itself. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a id="gaf202d20209b04c9ea9fd0657f3cfccc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf202d20209b04c9ea9fd0657f3cfccc6">&#9670;&nbsp;</a></span>hashtable_global_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_global_config </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t)&#160;</td>
          <td class="paramname"><em>alloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, size_t)&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const char *)&#160;</td>
          <td class="paramname"><em>assert_fail_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The hashtable has parametrized heap and assert routines for flexibility. This routine must be called BEFORE any other hashtable_ routine; else, the defaults will be used. </p>

</div>
</div>
<a id="ga96d69f3a60f5ba9c75698649465be695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96d69f3a60f5ba9c75698649465be695">&#9670;&nbsp;</a></span>hashtable_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&#160;</td>
          <td class="paramname"><em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>str_dup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a hashtable with the given size, hash type, and whether to duplicate string keys. All operations are synchronized by default. </p>

</div>
</div>
<a id="ga307d17165381371418414308b3eed803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga307d17165381371418414308b3eed803">&#9670;&nbsp;</a></span>hashtable_init_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init_ex </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&#160;</td>
          <td class="paramname"><em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>str_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_payload_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint(*)(void *)&#160;</td>
          <td class="paramname"><em>hash_key_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>cmp_key_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a hashtable with the given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">table</td><td>The hashtable to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_bits</td><td>The initial number of bits to use for the hash key which determines the initial size of the table itself. The result of the hash function will be truncated to this size. This size will be increased when the table is resized (resizing always doubles the size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtype</td><td>The type of hash to perform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_dup</td><td>Whether to duplicate string keys. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synch</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the hashtable's lock is initialized and can be used via <a class="el" href="group__drcontainers.html#ga98ba198cad4e146607e8a07db005b514">hashtable_lock()</a> and <a class="el" href="group__drcontainers.html#ga8d7f9e88180c79d080113e2bec858dbf">hashtable_unlock()</a>, allowing the caller to extend synchronization beyond just the operation in question, to include accessing a looked-up payload, e.g. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_payload_func</td><td>A callback for freeing each payload. Leave it NULL if no callback is needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_key_func</td><td>A callback for hashing a key. Leave it NULL if no callback is needed and the default is to be used. For HASH_CUSTOM, a callback must be provided. The hash operation can return a full uint, as its result will be truncated via a mod of the hash key bit size. This allows for resizing the table without changing the hash operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_key_func</td><td>A callback for comparing two keys. Leave it NULL if no callback is needed and the default is to be used. For HASH_CUSTOM, a callback must be provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98ba198cad4e146607e8a07db005b514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98ba198cad4e146607e8a07db005b514">&#9670;&nbsp;</a></span>hashtable_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_lock </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the hashtable lock. </p>

</div>
</div>
<a id="gac15c2ca65b95597ff2311f1040f1be53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac15c2ca65b95597ff2311f1040f1be53">&#9670;&nbsp;</a></span>hashtable_lock_self_owns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_lock_self_owns </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the hashtable lock is owned by the calling thread. This routine is only available in debug builds. In release builds it always returns true. </p>

</div>
</div>
<a id="gaa6af018f2bb18648861e76bc0fdec96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6af018f2bb18648861e76bc0fdec96e">&#9670;&nbsp;</a></span>hashtable_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_lookup </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the payload for the given key, or NULL if the key is not found </p>

</div>
</div>
<a id="ga012f1fb1127c60d90bd76d662c3dbf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga012f1fb1127c60d90bd76d662c3dbf4a">&#9670;&nbsp;</a></span>hashtable_persist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_persist </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For use persisting a table of single-alloc entries (i.e., via a shallow copy) for loading into a live table later.</p>
<p>These routines assume that the caller is synchronizing across the call to <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>. If these are called using DR's persistence interface, DR guarantees synchronization.</p>
<p><a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> must be called immediately prior to calling <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The opaque DR context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>The table to persist </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The target persisted file handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perscxt</td><td>The opaque persistence context from DR's persist events </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Controls various aspects of the persistence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3d52ff455ac9bab9ef5ffe49586e904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3d52ff455ac9bab9ef5ffe49586e904">&#9670;&nbsp;</a></span>hashtable_persist_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashtable_persist_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For use persisting a table of single-alloc entries (i.e., via a shallow copy) for loading into a live table later.</p>
<p>These routines assume that the caller is synchronizing across the call to <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>. If these are called using DR's persistence interface, DR guarantees synchronization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The opaque DR context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>The table to persist </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perscxt</td><td>The opaque persistence context from DR's persist events </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Controls various aspects of the persistence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8972b42e34447e229489ab120271dbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8972b42e34447e229489ab120271dbfd">&#9670;&nbsp;</a></span>hashtable_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_remove </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the entry for key. If free_payload_func was specified calls it for the payload being removed. Returns false if no such entry exists. </p>

</div>
</div>
<a id="ga4a9699afdfaab140f2e98b7783a51b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a9699afdfaab140f2e98b7783a51b19">&#9670;&nbsp;</a></span>hashtable_remove_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_remove_range </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all entries with key in [start..end). If free_payload_func was specified calls it for each payload being removed. Returns false if no such entry exists. </p>

</div>
</div>
<a id="ga5857998e61b2477997fad25adf71580b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5857998e61b2477997fad25adf71580b">&#9670;&nbsp;</a></span>hashtable_resurrect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_resurrect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *key, void *payload, ptr_int_t shift)&#160;</td>
          <td class="paramname"><em>process_payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For use persisting a table of single-alloc entries (i.e., via a shallow copy) for loading into a live table later.</p>
<p>Reads in entries from disk and adds them to the live table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The opaque DR context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapped-in persisted file, pointing at the data written by <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>The live table to add to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perscxt</td><td>The opaque persistence context from DR's persist events </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Controls various aspects of the persistence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">process_payload</td><td>If non-NULL, calls process_payload instead of hashtable_add. process_payload can then adjust the paylod and if it wishes invoke hashtable_add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d7f9e88180c79d080113e2bec858dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7f9e88180c79d080113e2bec858dbf">&#9670;&nbsp;</a></span>hashtable_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_unlock </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the hashtable lock. </p>

</div>
</div>
<a id="gab341e9839c6cbd89a5a442df73468f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab341e9839c6cbd89a5a442df73468f5f">&#9670;&nbsp;</a></span>stri_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stri_eq </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caseless string compare </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
