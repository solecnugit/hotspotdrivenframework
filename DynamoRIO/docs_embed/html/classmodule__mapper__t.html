---
title: "module_mapper_t Class Reference"
layout: default
permalink: /classmodule__mapper__t.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">module_mapper_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;raw2trace.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1445cda907aa2fee4d667cd8b7e5a3e4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__mapper__t.html#a1445cda907aa2fee4d667cd8b7e5a3e4">get_last_error</a> (void) const</td></tr>
<tr class="separator:a1445cda907aa2fee4d667cd8b7e5a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc0d9c7f1afc3316b0c7edbc6325178"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; module_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__mapper__t.html#a1cc0d9c7f1afc3316b0c7edbc6325178">get_loaded_modules</a> ()</td></tr>
<tr class="separator:a1cc0d9c7f1afc3316b0c7edbc6325178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0cc122b72c75d519971cde9eeffd87"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__mapper__t.html#add0cc122b72c75d519971cde9eeffd87">find_mapped_trace_address</a> (app_pc trace_address)</td></tr>
<tr class="separator:add0cc122b72c75d519971cde9eeffd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174c1c59c9005e5ec414cc8ef47674e7"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__mapper__t.html#a174c1c59c9005e5ec414cc8ef47674e7">find_mapped_trace_bounds</a> (app_pc trace_address, OUT app_pc *module_start, OUT size_t *module_size)</td></tr>
<tr class="separator:a174c1c59c9005e5ec414cc8ef47674e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa564b038b405e47a8ccf78129e3b7e29"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__mapper__t.html#aa564b038b405e47a8ccf78129e3b7e29">~module_mapper_t</a> ()</td></tr>
<tr class="separator:aa564b038b405e47a8ccf78129e3b7e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243cff220ab3d57f59203177a44d8b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drcovlib.html#gae9a3c543d0016b39bfc24748076f83af">drcovlib_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__mapper__t.html#a243cff220ab3d57f59203177a44d8b08">write_module_data</a> (char *buf, size_t buf_size, int(*print_cb)(void *data, char *dst, size_t max_len), OUT size_t *wrote)</td></tr>
<tr class="separator:a243cff220ab3d57f59203177a44d8b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aee56dbea310a6318fd63bf1fb477f566"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classmodule__mapper__t.html">module_mapper_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__mapper__t.html#aee56dbea310a6318fd63bf1fb477f566">create</a> (const char *module_map, const char *(*parse_cb)(const char *src, OUT void **data)=nullptr, std::string(*process_cb)(<a class="el" href="group__drcovlib.html#ga70dd4ae0fcab1e7c8c090977eeeefa02">drmodtrack_info_t</a> *info, void *data, void *user_data)=nullptr, void *process_cb_user_data=nullptr, void(*free_cb)(void *data)=nullptr, uint verbosity=0, const std::string &amp;alt_module_dir=&quot;&quot;)</td></tr>
<tr class="separator:aee56dbea310a6318fd63bf1fb477f566"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmodule__mapper__t.html">module_mapper_t</a> maps and unloads application modules. Using it assumes a dr_context has already been setup. This class is not thread-safe. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa564b038b405e47a8ccf78129e3b7e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa564b038b405e47a8ccf78129e3b7e29">&#9670;&nbsp;</a></span>~module_mapper_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual module_mapper_t::~module_mapper_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unload modules loaded with read_and_map_modules(), freeing associated resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aee56dbea310a6318fd63bf1fb477f566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee56dbea310a6318fd63bf1fb477f566">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classmodule__mapper__t.html">module_mapper_t</a>&gt; module_mapper_t::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *(*)(const char *src, OUT void **data)&#160;</td>
          <td class="paramname"><em>parse_cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string(*)(<a class="el" href="group__drcovlib.html#ga70dd4ae0fcab1e7c8c090977eeeefa02">drmodtrack_info_t</a> *info, void *data, void *user_data)&#160;</td>
          <td class="paramname"><em>process_cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>process_cb_user_data</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *data)&#160;</td>
          <td class="paramname"><em>free_cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alt_module_dir</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses and iterates over the list of modules. This is provided to give the user a method for iterating modules in the presence of the custom field used by drmemtrace that prevents direct use of <a class="el" href="group__drcovlib.html#ga56c631d77cd329a831116424204a2011">drmodtrack_offline_read()</a>. Its parsing of the module data will invoke <code>parse_cb</code>, which should advance the module data pointer passed in <code>src</code> and return it as its return value (or nullptr on error), returning the resulting parsed data in <code>data</code>. The <code>data</code> pointer will afterwards be passed to both <code>process_cb</code>, which can update the module path inside <code>info</code> (and return a non-empty string on error), and <b>free_cb</b>, which can perform cleanup.</p>
<p>The callbacks will only be called during object construction.</p>
<p>On success, calls the <code>process_cb</code> function for every module in the list. On failure, <a class="el" href="classmodule__mapper__t.html#a1445cda907aa2fee4d667cd8b7e5a3e4">get_last_error()</a> is non-empty, and indicates the cause. </p>

</div>
</div>
<a id="add0cc122b72c75d519971cde9eeffd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0cc122b72c75d519971cde9eeffd87">&#9670;&nbsp;</a></span>find_mapped_trace_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc module_mapper_t::find_mapped_trace_address </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>trace_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This interface is meant to be used with a final trace rather than a raw trace, using the module log file saved from the raw2trace conversion. After the a call to <a class="el" href="classmodule__mapper__t.html#a1cc0d9c7f1afc3316b0c7edbc6325178">get_loaded_modules()</a>, this routine may be used to convert an instruction program counter in a trace into an address in the current process where the instruction bytes for that instruction are mapped, allowing decoding for obtaining further information than is stored in the trace. Returns the mapped address. Check get_last_error_() if an error occurred. </p>

</div>
</div>
<a id="a174c1c59c9005e5ec414cc8ef47674e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174c1c59c9005e5ec414cc8ef47674e7">&#9670;&nbsp;</a></span>find_mapped_trace_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc module_mapper_t::find_mapped_trace_bounds </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>trace_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&#160;</td>
          <td class="paramname"><em>module_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT size_t *&#160;</td>
          <td class="paramname"><em>module_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is identical to <a class="el" href="classmodule__mapper__t.html#add0cc122b72c75d519971cde9eeffd87">find_mapped_trace_address()</a> but it also returns the bounds of the containing region, allowing the caller to perform its own mapping for any address that is also within those bounds. </p>

</div>
</div>
<a id="a1445cda907aa2fee4d667cd8b7e5a3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1445cda907aa2fee4d667cd8b7e5a3e4">&#9670;&nbsp;</a></span>get_last_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string module_mapper_t::get_last_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All APIs on this type, including constructor, may fail. <a class="el" href="classmodule__mapper__t.html#a1445cda907aa2fee4d667cd8b7e5a3e4">get_last_error()</a> returns the last error message. The object should be considered unusable if !get_last_error().empty(). </p>

</div>
</div>
<a id="a1cc0d9c7f1afc3316b0c7edbc6325178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc0d9c7f1afc3316b0c7edbc6325178">&#9670;&nbsp;</a></span>get_loaded_modules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;module_t&gt;&amp; module_mapper_t::get_loaded_modules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>module_t vector corresponding to the application modules. Lazily loads and caches modules. If the object is invalid, returns an empty vector. The user may check <a class="el" href="classmodule__mapper__t.html#a1445cda907aa2fee4d667cd8b7e5a3e4">get_last_error()</a> to ensure no error has occurred, or get the applicable error message. </p>

</div>
</div>
<a id="a243cff220ab3d57f59203177a44d8b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243cff220ab3d57f59203177a44d8b08">&#9670;&nbsp;</a></span>write_module_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drcovlib.html#gae9a3c543d0016b39bfc24748076f83af">drcovlib_status_t</a> module_mapper_t::write_module_data </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *data, char *dst, size_t max_len)&#160;</td>
          <td class="paramname"><em>print_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT size_t *&#160;</td>
          <td class="paramname"><em>wrote</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes out the module list to <code>buf</code>, whose capacity is <code>buf_size</code>. The written data includes any modifications made by the <code>process_cb</code> passed to <a class="el" href="classmodule__mapper__t.html#aee56dbea310a6318fd63bf1fb477f566">create()</a>. Any custom data returned by the <code>parse_cb</code> passed to <a class="el" href="classmodule__mapper__t.html#aee56dbea310a6318fd63bf1fb477f566">create()</a> is passed to <code>print_cb</code> here for serialization. The <code>print_cb</code> must return the number of characters printed or -1 on error. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/dynamorio/dynamorio/build_release-64/clients/include/drmemtrace/<a class="el" href="raw2trace_8h.html">raw2trace.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
