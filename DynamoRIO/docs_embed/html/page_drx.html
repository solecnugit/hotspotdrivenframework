---
title: "DynamoRIO eXtension utilities"
layout: default
permalink: /page_drx.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">DynamoRIO eXtension utilities </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <code>drx</code> DynamoRIO Extension provides various utilities for instrumentation and sports a BSD license, as opposed to the <code>drutil</code> Extension which also contains instrumentation utilities but uses an LGPL 2.1 license.</p>
<ul>
<li><a class="el" href="page_drx.html#sec_drx_setup">Setup</a></li>
<li><a class="el" href="page_drx.html#sec_drx_soft_kills">Soft Kills</a></li>
</ul>
<h1><a class="anchor" id="sec_drx_setup"></a>
Setup</h1>
<p>To use <code>drx</code> with your client simply include this line in your client's <code>CMakeLists.txt</code> file:</p>
<div class="fragment"><div class="line">use_DynamoRIO_extension(clientname drx) </div>
</div><!-- fragment --><p>That will automatically set up the include path and library dependence.</p>
<p>The <code><a class="el" href="group__drx.html#gae0665a86427616ffc80c59375649e283">drx_init()</a></code> function may be called multiple times; subsequent calls will be nops and will return <code>true</code> for success. This allows a library to use <code>drx</code> without coordinating with the client over who invokes <code><a class="el" href="group__drx.html#gae0665a86427616ffc80c59375649e283">drx_init()</a></code>.</p>
<h1><a class="anchor" id="sec_drx_soft_kills"></a>
Soft Kills</h1>
<p>A common scenario with multi-process applications is for a parent process to directly kill child processes. This is problematic for most dynamic tools as this leaves no chance for each child process to output the results of its instrumentation. On Windows, <code>drx</code> provides a feature called "soft
kills" to address this situation. When enabled, this feature monitors system calls that terminate child processes, whether directly or through job objects. When detected, it notifies the client, who is expected to then notify the target process via a nudge. Typically this nudge will perform instrumentation output and then terminate its process, allowing the parent to simply skip its own termination request. The nudge handler should normally handle multiple requests, as it is not uncommon for the parent to kill each child process through multiple mechanisms.</p>
<h1><a class="anchor" id="sec_drx_buf"></a>
Buffer Filling API</h1>
<p>The <code>drx</code> library also demonstrates a minimalistic buffer API. Its API is currently in flux. These buffers may contain traces of data gathered during instrumentation, such as memory traces, instruction traces, etc. Note that per-thread buffers are used for all implementations. There currently exist three types of buffers.</p>
<ul>
<li><a class="el" href="page_drx.html#sec_drx_buf_trace">Trace Buffer</a></li>
<li><a class="el" href="page_drx.html#sec_drx_buf_circular">Circular Buffer</a></li>
<li><a class="el" href="page_drx.html#sec_drx_buf_circular_fast">Fast Circular Buffer</a></li>
<li><a class="el" href="page_drx.html#sec_drx_buf_api">Using the Buffer API</a></li>
<li><a class="el" href="page_drx.html#sec_drx_buf_no_api">Manually Modifying the Buffer</a></li>
</ul>
<h1><a class="anchor" id="sec_drx_buf_trace"></a>
Trace Buffer</h1>
<p>The trace buffer notifies the user when the buffer fills up and allows the client to write the contents to disk or to a pipe, etc. Note that writing multiple fields of a struct to the buffer runs the risk of the client being notified that the buffer is filled before the entire struct has been written. In order to circumvent this limitation, either write the element at the highest offset in the struct first, so that the user never sees an incompletely-written struct, or if this is not possible, allocate a buffer whose size is a multiple of the size of the struct.</p>
<h1><a class="anchor" id="sec_drx_buf_circular"></a>
Circular Buffer</h1>
<p>This circular buffer will wrap around when it becomes full, and is used when a client might only need to remember the most recent portion of a sequence of events instead of recording an entire trace of events. This circular buffer can be any size, but is specially optimized for a buffer size of 65336.</p>
<h1><a class="anchor" id="sec_drx_buf_circular_fast"></a>
Fast Circular Buffer</h1>
<p>The only special case mentioned in <a class="el" href="page_drx.html#sec_drx_buf_circular">Circular Buffer</a> is a buffer of size 65336. Because the buffer is this size exactly, we can align it to a 65336 byte boundary, and increment only the bottom two bytes of the base pointer. By this method we are able to wrap around on overflow.</p>
<p>Note that this buffer is very good for homogeneous writes, such as in the sample client <code>bbuf</code> (see <a class="el" href="API_samples.html">Sample Tools</a>), where we only write <code>app_pc</code> sized values. Since the buffer cannot be a different size, when using a structure it is a good idea to increment <code>buf_ptr</code> to a size that evenly divides the size of the buffer.</p>
<h1><a class="anchor" id="sec_drx_buf_api"></a>
Using the Buffer API</h1>
<p>There is a single API for modifying the buffer which is compatible with each of these buffer types. The user must generally load the buffer pointer into a register, perform some store operations relative to the register, and then finally update the buffer pointer to accommodate these stores. Using offsets for subsequent fields in a structure is the most efficient method, but please note the warning in <a class="el" href="page_drx.html#sec_drx_buf_trace">Trace Buffer</a>, where one should either allocate an integer multiple of the size of the struct, or always write the last field of a struct first.</p>
<div class="fragment"><div class="line"><span class="comment">/* load the buffer pointer into reg_ptr */</span></div>
<div class="line"><a class="code" href="group__drx.html#ga42f82cda96d7ee9c3236ab520f192d96">drx_buf_insert_load_buf_ptr</a>(drcontext, buf, bb, inst, reg_ptr);</div>
<div class="line"><span class="comment">/* Store whatever is in the scratch reg to the buffer at offset 0, and then</span></div>
<div class="line"><span class="comment"> * to offset 8.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code" href="group__drx.html#ga707a2f43fd22d2203d1274a498e7cf8b">drx_buf_insert_buf_store</a>(drcontext, buf, bb, inst, reg_ptr,</div>
<div class="line">                         <a class="code" href="dr__ir__opnd_8h.html#ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882">DR_REG_NULL</a>, <a class="code" href="dr__ir__opnd_8h.html#ae6cf2a1e25144a7c81b3b3a4a89f8dda">opnd_create_reg</a>(scratch1), <a class="code" href="dr__ir__opnd_8h.html#a992970f92f717142180ea31fe5eb2493">OPSZ_PTR</a>, 0);</div>
<div class="line"><a class="code" href="group__drx.html#ga707a2f43fd22d2203d1274a498e7cf8b">drx_buf_insert_buf_store</a>(drcontext, buf, bb, inst, reg_ptr,</div>
<div class="line">                         <a class="code" href="dr__ir__opnd_8h.html#ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882">DR_REG_NULL</a>, <a class="code" href="dr__ir__opnd_8h.html#ae6cf2a1e25144a7c81b3b3a4a89f8dda">opnd_create_reg</a>(scratch2), <a class="code" href="dr__ir__opnd_8h.html#a992970f92f717142180ea31fe5eb2493">OPSZ_PTR</a>, 8);</div>
<div class="line"><span class="comment">/* We wrote 16 bytes (8 bytes of scratch1 and 8 bytes of scratch2), so we</span></div>
<div class="line"><span class="comment"> * increment the buffer pointer by that amount, using reg_tmp as a temporary</span></div>
<div class="line"><span class="comment"> * scratch register.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code" href="group__drx.html#ga187d0c9f694b5bbd97a509c72c3cccf6">drx_buf_insert_update_buf_ptr</a>(drcontext, buf, bb, inst, reg_ptr,</div>
<div class="line">                              reg_tmp, <span class="keyword">sizeof</span>(reg_t)*2);</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_drx_buf_no_api"></a>
Manually Modifying the Buffer</h1>
<p>It is possible to manually modify the buffer without calling <a class="el" href="group__drx.html#ga707a2f43fd22d2203d1274a498e7cf8b">drx_buf_insert_buf_store()</a>. The provided store routines are for convenience only, to ensure that an app translation is set for each instruction. If a user writes to the buffer without using the provided operations, please make sure an app translation is set. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="adr__ir__opnd_8h_html_ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882"><div class="ttname"><a href="dr__ir__opnd_8h.html#ab04a0655cd1e3bcac5e8f48c18df1a57a3b7e285b0a732b7da09c0f65a66f7882">DR_REG_NULL</a></div><div class="ttdeci">@ DR_REG_NULL</div><div class="ttdef"><b>Definition:</b> dr_ir_opnd.h:292</div></div>
<div class="ttc" id="adr__ir__opnd_8h_html_ae6cf2a1e25144a7c81b3b3a4a89f8dda"><div class="ttname"><a href="dr__ir__opnd_8h.html#ae6cf2a1e25144a7c81b3b3a4a89f8dda">opnd_create_reg</a></div><div class="ttdeci">DR_API INSTR_INLINE opnd_t opnd_create_reg(reg_id_t r)</div></div>
<div class="ttc" id="agroup__drx_html_ga707a2f43fd22d2203d1274a498e7cf8b"><div class="ttname"><a href="group__drx.html#ga707a2f43fd22d2203d1274a498e7cf8b">drx_buf_insert_buf_store</a></div><div class="ttdeci">DR_EXPORT bool drx_buf_insert_buf_store(void *drcontext, drx_buf_t *buf, instrlist_t *ilist, instr_t *where, reg_id_t buf_ptr, reg_id_t scratch, opnd_t opnd, opnd_size_t opsz, short offset)</div></div>
<div class="ttc" id="adr__ir__opnd_8h_html_a992970f92f717142180ea31fe5eb2493"><div class="ttname"><a href="dr__ir__opnd_8h.html#a992970f92f717142180ea31fe5eb2493">OPSZ_PTR</a></div><div class="ttdeci">#define OPSZ_PTR</div><div class="ttdef"><b>Definition:</b> dr_ir_opnd.h:228</div></div>
<div class="ttc" id="agroup__drx_html_ga187d0c9f694b5bbd97a509c72c3cccf6"><div class="ttname"><a href="group__drx.html#ga187d0c9f694b5bbd97a509c72c3cccf6">drx_buf_insert_update_buf_ptr</a></div><div class="ttdeci">DR_EXPORT void drx_buf_insert_update_buf_ptr(void *drcontext, drx_buf_t *buf, instrlist_t *ilist, instr_t *where, reg_id_t buf_ptr, reg_id_t scratch, ushort stride)</div></div>
<div class="ttc" id="agroup__drx_html_ga42f82cda96d7ee9c3236ab520f192d96"><div class="ttname"><a href="group__drx.html#ga42f82cda96d7ee9c3236ab520f192d96">drx_buf_insert_load_buf_ptr</a></div><div class="ttdeci">DR_EXPORT void drx_buf_insert_load_buf_ptr(void *drcontext, drx_buf_t *buf, instrlist_t *ilist, instr_t *where, reg_id_t buf_ptr)</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
