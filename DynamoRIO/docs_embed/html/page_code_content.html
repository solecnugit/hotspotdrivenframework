---
title: "Code Content Guidelines"
layout: default
permalink: /page_code_content.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Code Content Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>See also <a class="el" href="page_workflow.html">Development Workflow</a> and <a class="el" href="page_code_style.html">Coding Style Conventions</a>.</p>
<h1><a class="anchor" id="autotoc_md105"></a>
Adding New Features</h1>
<ol type="1">
<li>A new feature should be added under its own preprocessor define as well as under its own off-by-default runtime option, to facilitate incremental development and testing. Once it is working properly, the ifdefs can be removed. Once it is proven to be worthwhile and robust, the option can be turned on by default.</li>
<li>For new client frameworks, or utility routines that are not present in DynamoRIO itself, consider adding the feature(s) as a DynamoRIO Extension. A DynamoRIO Extension is a shared or static library that is packaged with DynamoRIO for easy use by clients. Its sources live in the DynamoRIO repository in the ext/ directory, and its documentation is included as a section in the DynamoRIO documentation.</li>
<li>Code reviews are required for any commit, regardless of how trivial.</li>
<li>Add a new regression test, or augment an existing test, to test your new feature.</li>
<li>If your feature involves new runtime options, consider adding new regression suite runs for the option.</li>
<li>If your feature involves new API routines, consider adding a new sample client that uses the feature.</li>
<li>If your feature is user-visible, add it to api/docs/release.dox in the list of new features added to the next release.</li>
<li>Use assertions whenever an assumption is made. We have several types of ASSERT macros: use the appropriate one. For any API-visible function, use CLIENT_ASSERT to provide an understandable string to the user.</li>
<li>Add a new statistic to <code>core/lib/statsx.h</code> for anything we might want to keep track of.</li>
<li>Be careful with locks. Make sure to follow our deadlock-avoidance scheme when adding a new lock: add it to the list in <code>core/utils.h</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md106"></a>
Backward Compatibility</h1>
<ol type="1">
<li>Remember that the DynamoRIO API is an interface used by many people. Do not take changes to the interface lightly. In general strive to avoid breaking either source compatibility or binary compatibility, though for us source is more important.</li>
<li>If we decided that changing an interface is required, please update the changelog in api/docs/release.dox with a description of the change and a note that it breaks either binary or source compatibility.</li>
</ol>
<h1><a class="anchor" id="autotoc_md107"></a>
Security</h1>
<ol type="1">
<li>Be security aware. Carefully watch your buffers and input validation to avoid introducing vulnerabilities.</li>
<li>Do not use unsafe string routines. Never use <code>strcpy</code> or <code>sprintf</code>: use <code>strncpy</code> and <code>snprintf</code> instead. Use BUFFER_SIZE_ELEMENTS() for the size of statically-sized buffers. Always null-terminate buffers after calling <code>strncpy</code> or <code>snprintf</code>: for statically-sized buffers, use NULL_TERMINATE_BUFFER().</li>
<li><p class="startli">Variable placement: <b>.data is read-only!</b></p>
<p class="startli">For self-protection from inadvertent or malicious application activity, DynamoRIO uses a non-standard data section layout with five separate sections:</p><ul>
<li><p class="startli"><b>.rdata</b> = read-only data</p>
<p class="startli">Mark all non-written variables as <code>const</code> to get them into this section.</p>
</li>
<li><p class="startli"><b>.data</b> = rarely-written data</p>
<p class="startli">Variables that are written only during initialization, cleanup, or a handful of times during execution. This section is write-protected by default and only unprotected for small, infrequent windows of time. This is the default location for a variable (even if in .bss, if on Windows, though not on Linux currently due to PR 213296), so if you write to your new default-location variable after initialization <b>DynamoRIO will crash</b>! In debug builds a special self-protection message will alert you to crashes coming from attempts to write to .data.</p>
<p class="startli">If you must write to a variable after initialization, you can either unprotect it with this pair of macros (however, see the next item):</p>
<p class="startli"><code>SELF_UNPROTECT_DATASEC(DATASEC_RARELY_PROT);</code></p>
<p class="startli"><code>SELF_PROTECT_DATASEC(DATASEC_RARELY_PROT);</code></p>
<p class="startli">Or you can move it to another section, probably .fspdata, like this:</p>
<p class="startli"><code>DECLARE_FREQPROT_VAR(static vartype myvar, initial-value);</code></p>
<p class="startli">Only unprotect if you write <b>very infrequently</b>, as in zero times on any critical path. Keep an eye on the stats for unprotection calls and make sure you're not affecting performance and not opening up too many windows where the entire .data section is unprotected.</p>
<p class="startli">Do not keep pointers in a data section other than .data. If they must be writable, use indirection and keep them on the heap.</p>
<p class="startli">Think about whether non-pointers (booleans, counters) can be exploited before throwing them into unprotected sections. Can an overwrite of the variable in question cause us to stop protecting the application, or to lose control of the application?</p>
<p class="startli">Place all locks in .cspdata.</p>
<p class="startli">Be aware that <code>DO_ONCE</code> introduces a window where .data is unprotected (see PR 212510).</p>
</li>
<li><p class="startli"><b>.fspdata</b> = frequently-written self-protected data</p>
<p class="startli">Variables that are written enough that we do not want to unprotect .data every time. We place them in a separate section called .fspdata (for "frequently self-protected data", referring to the number of times we need to change the page protections, which is proportional to the number of post-init writes) both for security and performance reasons. We moved any pointers in this category into structures on the heap, enabling us to move their base pointers into .data. Currently the heap is better protected than our data sections due to its better randomization and its guard pages. Try not to put new variables here as we hope to eventually eliminate this section. Note that this is not yet protected at all: PR 212508.</p>
</li>
<li><p class="startli"><b>.cspdata</b> = context-switch-written self-protected data</p>
<p class="startli">This is our section for locks, which are written so frequently that unprotecting them is best done at each context switch. Note that this is not yet protected at all: PR 212508.</p>
</li>
<li><p class="startli"><b>.nspdata</b> = not self-protected data</p>
<p class="startli">Debug-build-only variables, statistics, or data that is not persistent across code cache execution fall into this category of variables that we never protect. This section is always writable.</p>
</li>
</ul>
</li>
</ol>
<p>DynamoRIO has several other features for self-protection:</p>
<ol type="1">
<li>The base of its heap is randomized. This is why we consider writable pointers in the heap to be safer than writable pointers in a data section.</li>
<li>Guard pages protect both ends of every stack and heap unit to protect against sequential overwrites.</li>
<li>No state is kept on the DynamoRIO stack across code cache execution: execution starts from a clean slate at the base of the stack on every exit from the code cache.</li>
<li>Generated code is made read-only after initialization.</li>
<li>The options are made read-only after initialization. Now that we have .data read-only, this is simply part of that feature.</li>
<li>The base of the dynamorio.dll library is randomized.</li>
</ol>
<h1><a class="anchor" id="autotoc_md108"></a>
Transparency</h1>
<p>The DynamoRIO core must be absolutely transparent. It cannot interfere with the application's semantics. This means that extra care must be taken when using <b>any</b> operating system or shared library resources that might interact with the application's use of those resources. See the API documentation for more details. The following guidelines list some common mistakes to avoid.</p>
<ol type="1">
<li>Do not introduce new user library dependencies. On Windows we only use ntdll.dll, and there we only call routines that we are sure are re-entrant. On Linux, we have no library dependencies at all when using the default build and runtime options. Avoid adding any new library calls.</li>
<li>Never call any potentially non-reentrant library routines. These include malloc, calloc, fprintf, etc., and everything that calls these routines, such as strdup. Usually you'll be violating the prior point if you use these, but keep in mind that many ntdll.dll routines are non-reentrant because they acquire locks or allocate memory. Use raw system calls instead of library routines (yes we have hit many bugs due to using library routines).</li>
<li>Do not make any alertable system calls on Windows. This includes any <code>Wait*</code> API routine. Use the system calls instead, which let you specify whether it should be alertable or not.</li>
<li>For memory allocation, use either the local heap (via <code>heap_alloc</code>) or the global heap (via <code>global_heap_alloc</code>). (In certain circumstances, such as inside signal handlers, other heaps should be used.) Always de-allocate memory. We cannot assume we will last as long as the application, since we may be detached before the application exits.</li>
<li>For I/O, use the interfaces exported by the OS subdirectories. Do not use <code>stderr</code> or <code>stdout</code> &ndash; due to <code>FILE</code> problems on windows we use <code>HANDLE</code> on windows and hide the distinction behind the <code>file_t</code> type. Use the <code>STDERR</code> and <code>STDOUT</code> macros.</li>
<li>DO NOT USE FLOATING-POINT OPERATIONS! DynamoRIO does not save or restore floating-point state on context switches. You can use the routines <code>save_fpstate</code> and <code>restore_fpstate</code> (includes mmx &amp; sse state) around your code if you really need floating point operations.</li>
<li>DO NOT HOLD LOCKS ACROSS CODE CACHE EXECUTION! Doing so violates the assumptions of our synchronization algorithms. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:57 &nbsp; <img border=0 src="favicon.png">
</small></address>
