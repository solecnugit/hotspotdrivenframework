---
title: "Multi-Instrumentation Manager"
layout: default
permalink: /group__drmgr.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multi-Instrumentation Manager</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drmgr__priority__t.html">_drmgr_priority_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drmgr__instru__events__t.html">_drmgr_instru_events_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__emulated__instr__t.html">_emulated_instr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1260c94e5eb2b34a7af2c2e99b129568"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a>) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, bool for_trace, bool translating)</td></tr>
<tr class="separator:ga1260c94e5eb2b34a7af2c2e99b129568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c312b9deefda685e85620ed0c7c78d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga0c312b9deefda685e85620ed0c7c78d5">drmgr_analysis_cb_t</a>) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, bool for_trace, bool translating, OUT void **user_data)</td></tr>
<tr class="separator:ga0c312b9deefda685e85620ed0c7c78d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb8f7568c015abb3c26c78983bb7c533"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__drmgr.html#ga0c312b9deefda685e85620ed0c7c78d5">drmgr_analysis_cb_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a></td></tr>
<tr class="separator:gacb8f7568c015abb3c26c78983bb7c533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4983d7847f2c744a6e19fc9537f00ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a>) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, bool for_trace, bool translating, void *user_data)</td></tr>
<tr class="separator:gad4983d7847f2c744a6e19fc9537f00ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13a6681d00526e2360f2a6b13f0272aa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a>) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool for_trace, bool translating, void *user_data)</td></tr>
<tr class="separator:ga13a6681d00526e2360f2a6b13f0272aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4895c7d1731eae3076179b3aa7364343"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4895c7d1731eae3076179b3aa7364343">drmgr_opcode_insertion_cb_t</a>) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool for_trace, bool translating, void *user_data)</td></tr>
<tr class="separator:ga4895c7d1731eae3076179b3aa7364343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ea8251bfe11bcc02821ada3852e599"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drmgr__priority__t.html">_drmgr_priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a></td></tr>
<tr class="separator:gad1ea8251bfe11bcc02821ada3852e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa610b2e06d4bae362405a7792b4060e3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drmgr__instru__events__t.html">_drmgr_instru_events_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaa610b2e06d4bae362405a7792b4060e3">drmgr_instru_events_t</a></td></tr>
<tr class="separator:gaa610b2e06d4bae362405a7792b4060e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac779b3f5c1076450ad32083da0921768"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__emulated__instr__t.html">_emulated_instr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a></td></tr>
<tr class="separator:gac779b3f5c1076450ad32083da0921768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae3531e42d6cde87d19a63801ab6b9230"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gae3531e42d6cde87d19a63801ab6b9230">drmgr_bb_phase_t</a> { <br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggae3531e42d6cde87d19a63801ab6b9230ae5168599a479256d3b95839f57e5b985">DRMGR_PHASE_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggae3531e42d6cde87d19a63801ab6b9230a7eb5e7bcc7f6d533bcb8dcc10389441e">DRMGR_PHASE_APP2APP</a>, 
<br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggae3531e42d6cde87d19a63801ab6b9230a242a4f07729fd4b18c296263a7308faf">DRMGR_PHASE_ANALYSIS</a>, 
<br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggae3531e42d6cde87d19a63801ab6b9230a71f2ee3487696c6f969b06920b883dee">DRMGR_PHASE_INSERTION</a>, 
<br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggae3531e42d6cde87d19a63801ab6b9230ad4dab0dd27bdccf8b9d70727c9da5792">DRMGR_PHASE_INSTRU2INSTRU</a>, 
<br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggae3531e42d6cde87d19a63801ab6b9230a6a18072668addf9e8197b66756d8be09">DRMGR_PHASE_META_INSTRU</a>
<br />
 }</td></tr>
<tr class="separator:gae3531e42d6cde87d19a63801ab6b9230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa131b3cd2bf8aadb9ac196911aa6b32"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaaa131b3cd2bf8aadb9ac196911aa6b32">dr_emulate_options_t</a> { <br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggaaa131b3cd2bf8aadb9ac196911aa6b32a60a60d7210d981f2fb0692e125e00dc4">DR_EMULATE_REST_OF_BLOCK</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggaaa131b3cd2bf8aadb9ac196911aa6b32abba41ccc153c360ffe9bf664eca14c74">DR_EMULATE_IS_FIRST_INSTR</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="group__drmgr.html#ggaaa131b3cd2bf8aadb9ac196911aa6b32a526e36749e0fb1ca4e2a00a095a42efb">DR_EMULATE_INSTR_ONLY</a> = 0x0004
<br />
 }</td></tr>
<tr class="separator:gaaa131b3cd2bf8aadb9ac196911aa6b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga07ab03a2182247922f756778d18bb3fd"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga07ab03a2182247922f756778d18bb3fd">drmgr_init</a> (void)</td></tr>
<tr class="separator:ga07ab03a2182247922f756778d18bb3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e27214f63289548497d25c9e628a5d7"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga1e27214f63289548497d25c9e628a5d7">drmgr_exit</a> (void)</td></tr>
<tr class="separator:ga1e27214f63289548497d25c9e628a5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae270eeb1ab24d4e05f8588b23822f45c"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gae270eeb1ab24d4e05f8588b23822f45c">drmgr_register_bb_app2app_event</a> (<a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a> func, <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:gae270eeb1ab24d4e05f8588b23822f45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a83c67e54d71259e42b8e10abe62d6"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga22a83c67e54d71259e42b8e10abe62d6">drmgr_unregister_bb_app2app_event</a> (<a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a> func)</td></tr>
<tr class="separator:ga22a83c67e54d71259e42b8e10abe62d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a5fc96944e10bd7356e0c492c93966"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga83a5fc96944e10bd7356e0c492c93966">drmgr_register_bb_instrumentation_event</a> (<a class="el" href="group__drmgr.html#ga0c312b9deefda685e85620ed0c7c78d5">drmgr_analysis_cb_t</a> analysis_func, <a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a> insertion_func, <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga83a5fc96944e10bd7356e0c492c93966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff08fa96e523f613b7371835c5025422"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaff08fa96e523f613b7371835c5025422">drmgr_unregister_bb_instrumentation_event</a> (<a class="el" href="group__drmgr.html#ga0c312b9deefda685e85620ed0c7c78d5">drmgr_analysis_cb_t</a> func)</td></tr>
<tr class="separator:gaff08fa96e523f613b7371835c5025422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85890ca6d143f6a5218680484a25d3fb"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga85890ca6d143f6a5218680484a25d3fb">drmgr_unregister_bb_insertion_event</a> (<a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a> func)</td></tr>
<tr class="separator:ga85890ca6d143f6a5218680484a25d3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1f4cb66a41c81a12a8b37ba96083de"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2f1f4cb66a41c81a12a8b37ba96083de">drmgr_register_bb_instru2instru_event</a> (<a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a> func, <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga2f1f4cb66a41c81a12a8b37ba96083de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c692eb44a082c09833d13ed85360814"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4c692eb44a082c09833d13ed85360814">drmgr_unregister_bb_instru2instru_event</a> (<a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a> func)</td></tr>
<tr class="separator:ga4c692eb44a082c09833d13ed85360814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e4be9f62ffd954f2f95ba21ec92953"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga26e4be9f62ffd954f2f95ba21ec92953">drmgr_register_bb_instrumentation_ex_event</a> (<a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a> app2app_func, <a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a> analysis_func, <a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a> insertion_func, <a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a> instru2instru_func, <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga26e4be9f62ffd954f2f95ba21ec92953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6980f5fdc8f1f74ecaca53d0ef49c16a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga6980f5fdc8f1f74ecaca53d0ef49c16a">drmgr_unregister_bb_instrumentation_ex_event</a> (<a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a> app2app_func, <a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a> analysis_func, <a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a> insertion_func, <a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a> instru2instru_func)</td></tr>
<tr class="separator:ga6980f5fdc8f1f74ecaca53d0ef49c16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14834254df9e9ded4369063e5cfba909"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga14834254df9e9ded4369063e5cfba909">drmgr_register_opcode_instrumentation_event</a> (<a class="el" href="group__drmgr.html#ga4895c7d1731eae3076179b3aa7364343">drmgr_opcode_insertion_cb_t</a> func, int opcode, <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:ga14834254df9e9ded4369063e5cfba909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20ff5e38d676266d12f6641326bed87a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga20ff5e38d676266d12f6641326bed87a">drmgr_unregister_opcode_instrumentation_event</a> (<a class="el" href="group__drmgr.html#ga4895c7d1731eae3076179b3aa7364343">drmgr_opcode_insertion_cb_t</a> func, int opcode)</td></tr>
<tr class="separator:ga20ff5e38d676266d12f6641326bed87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d3c4cfcbfe46adcaa51efc12be8eafc"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga8d3c4cfcbfe46adcaa51efc12be8eafc">drmgr_register_bb_meta_instru_event</a> (<a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a> func, <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga8d3c4cfcbfe46adcaa51efc12be8eafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216b449b7681a092557cc78b45895899"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga216b449b7681a092557cc78b45895899">drmgr_unregister_bb_meta_instru_event</a> (<a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a> func)</td></tr>
<tr class="separator:ga216b449b7681a092557cc78b45895899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4917fd1c3d667e52fc77b48d1325d85b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4917fd1c3d667e52fc77b48d1325d85b">drmgr_register_bb_instrumentation_all_events</a> (<a class="el" href="group__drmgr.html#gaa610b2e06d4bae362405a7792b4060e3">drmgr_instru_events_t</a> *events, <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga4917fd1c3d667e52fc77b48d1325d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bda2cd032c29f0a9343265cc9cdf6bd"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2bda2cd032c29f0a9343265cc9cdf6bd">drmgr_unregister_bb_instrumentation_all_events</a> (<a class="el" href="group__drmgr.html#gaa610b2e06d4bae362405a7792b4060e3">drmgr_instru_events_t</a> *events)</td></tr>
<tr class="separator:ga2bda2cd032c29f0a9343265cc9cdf6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75f5e22831cb18cb7fbb8316cd56f09f"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmgr.html#gae3531e42d6cde87d19a63801ab6b9230">drmgr_bb_phase_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga75f5e22831cb18cb7fbb8316cd56f09f">drmgr_current_bb_phase</a> (void *drcontext)</td></tr>
<tr class="separator:ga75f5e22831cb18cb7fbb8316cd56f09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd8688fd6cc4d7e1f804ccd1460f5177"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gadd8688fd6cc4d7e1f804ccd1460f5177">drmgr_is_first_instr</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:gadd8688fd6cc4d7e1f804ccd1460f5177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7f56824be0f6b04d5b6353f0681d70"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga6d7f56824be0f6b04d5b6353f0681d70">drmgr_is_first_nonlabel_instr</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ga6d7f56824be0f6b04d5b6353f0681d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60452df11f634ad4633578ba5330d2c4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga60452df11f634ad4633578ba5330d2c4">drmgr_is_last_instr</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ga60452df11f634ad4633578ba5330d2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga512b4290d94b1874537e5b604cb27cab"><td class="memItemLeft" align="right" valign="top">DR_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga512b4290d94b1874537e5b604cb27cab">drmgr_register_tls_field</a> (void)</td></tr>
<tr class="separator:ga512b4290d94b1874537e5b604cb27cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0389d904f0e656f8a8777d850e6187f3"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga0389d904f0e656f8a8777d850e6187f3">drmgr_unregister_tls_field</a> (int idx)</td></tr>
<tr class="separator:ga0389d904f0e656f8a8777d850e6187f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade57b8de9ed73d579044aa8f12abfe8d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gade57b8de9ed73d579044aa8f12abfe8d">drmgr_get_tls_field</a> (void *drcontext, int idx)</td></tr>
<tr class="separator:gade57b8de9ed73d579044aa8f12abfe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92542bc4f09040f3085079e68d60f66"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field</a> (void *drcontext, int idx, void *value)</td></tr>
<tr class="separator:gac92542bc4f09040f3085079e68d60f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c72a35608998e6e359a3a652a7f97f7"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga7c72a35608998e6e359a3a652a7f97f7">drmgr_insert_read_tls_field</a> (void *drcontext, int idx, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:ga7c72a35608998e6e359a3a652a7f97f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e2ae3d0f058fb069db7969e390c881"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga65e2ae3d0f058fb069db7969e390c881">drmgr_insert_write_tls_field</a> (void *drcontext, int idx, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> scratch)</td></tr>
<tr class="separator:ga65e2ae3d0f058fb069db7969e390c881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933ff32be874004447af771283d0bcee"><td class="memItemLeft" align="right" valign="top">DR_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field</a> (void(*cb_init_func)(void *drcontext, bool new_depth), void(*cb_exit_func)(void *drcontext, bool thread_exit))</td></tr>
<tr class="separator:ga933ff32be874004447af771283d0bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab638b9a9480b505e6ae323ffb72bb1d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaab638b9a9480b505e6ae323ffb72bb1d">drmgr_unregister_cls_field</a> (void(*cb_init_func)(void *drcontext, bool new_depth), void(*cb_exit_func)(void *drcontext, bool thread_exit), int idx)</td></tr>
<tr class="separator:gaab638b9a9480b505e6ae323ffb72bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67585e915e3f9b555ea4382ed6027812"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field</a> (void *drcontext, int idx)</td></tr>
<tr class="separator:ga67585e915e3f9b555ea4382ed6027812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3bc85402a8909c862d9c06d415f138"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field</a> (void *drcontext, int idx, void *value)</td></tr>
<tr class="separator:ga5d3bc85402a8909c862d9c06d415f138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba85528be6e0126b45a76245b6b4b001"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaba85528be6e0126b45a76245b6b4b001">drmgr_insert_read_cls_field</a> (void *drcontext, int idx, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:gaba85528be6e0126b45a76245b6b4b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d2757949d817bae787612177c00d85"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaa1d2757949d817bae787612177c00d85">drmgr_insert_write_cls_field</a> (void *drcontext, int idx, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> scratch)</td></tr>
<tr class="separator:gaa1d2757949d817bae787612177c00d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a70abba090ee410babc6a1548bb21d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gae2a70abba090ee410babc6a1548bb21d">drmgr_push_cls</a> (void *drcontext)</td></tr>
<tr class="separator:gae2a70abba090ee410babc6a1548bb21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac55faa0a4274ab5d8ac1cbd247b569"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4ac55faa0a4274ab5d8ac1cbd247b569">drmgr_pop_cls</a> (void *drcontext)</td></tr>
<tr class="separator:ga4ac55faa0a4274ab5d8ac1cbd247b569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f53520da678e84fd7712e2fcca0182b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4f53520da678e84fd7712e2fcca0182b">drmgr_get_parent_cls_field</a> (void *drcontext, int idx)</td></tr>
<tr class="separator:ga4f53520da678e84fd7712e2fcca0182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057f980fa9323a0bb8a4226c7c52c14a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga057f980fa9323a0bb8a4226c7c52c14a">drmgr_reserve_note_range</a> (size_t size)</td></tr>
<tr class="separator:ga057f980fa9323a0bb8a4226c7c52c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b96a01f3fa0ce7ad6a5f675965d952"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga94b96a01f3fa0ce7ad6a5f675965d952">drmgr_insert_emulation_start</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a> *instr)</td></tr>
<tr class="separator:ga94b96a01f3fa0ce7ad6a5f675965d952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7dd031774c812d485d4910846fbb73"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2f7dd031774c812d485d4910846fbb73">drmgr_insert_emulation_end</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:ga2f7dd031774c812d485d4910846fbb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4a20b19e779581dccac41eca9bf8321"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gae4a20b19e779581dccac41eca9bf8321">drmgr_is_emulation_start</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:gae4a20b19e779581dccac41eca9bf8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2227473141100828d097eb98828b954"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaf2227473141100828d097eb98828b954">drmgr_is_emulation_end</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:gaf2227473141100828d097eb98828b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b025c766a84bee841288d822b15380"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga85b025c766a84bee841288d822b15380">drmgr_get_emulated_instr_data</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, OUT <a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a> *emulated)</td></tr>
<tr class="separator:ga85b025c766a84bee841288d822b15380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ca9b0961ad0b562318702897df729b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga37ca9b0961ad0b562318702897df729b">drmgr_in_emulation_region</a> (void *drcontext, OUT const <a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a> **emulation_info)</td></tr>
<tr class="separator:ga37ca9b0961ad0b562318702897df729b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad375fb1c1a8683c54a78f4f5b9951f4a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gad375fb1c1a8683c54a78f4f5b9951f4a">drmgr_orig_app_instr_for_fetch</a> (void *drcontext)</td></tr>
<tr class="separator:gad375fb1c1a8683c54a78f4f5b9951f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6373ac13132abb039c7d0593bde073ba"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga6373ac13132abb039c7d0593bde073ba">drmgr_orig_app_instr_for_operands</a> (void *drcontext)</td></tr>
<tr class="separator:ga6373ac13132abb039c7d0593bde073ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga357735ce7daa0bb717556455f20040a5"><td class="memItemLeft" align="right" valign="top">DR_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga357735ce7daa0bb717556455f20040a5">drmgr_decode_sysnum_from_wrapper</a> (app_pc entry)</td></tr>
<tr class="separator:ga357735ce7daa0bb717556455f20040a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac050cf70682f6fcb8e28aa942705cd"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaaac050cf70682f6fcb8e28aa942705cd">drmgr_register_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:gaaac050cf70682f6fcb8e28aa942705cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d894ba37e777790c9dec6f265892cb"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaf5d894ba37e777790c9dec6f265892cb">drmgr_register_thread_init_event_ex</a> (void(*func)(void *drcontext), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:gaf5d894ba37e777790c9dec6f265892cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798b4ae5da79d21d0e0b1a4eb962c950"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga798b4ae5da79d21d0e0b1a4eb962c950">drmgr_register_thread_init_event_user_data</a> (void(*func)(void *drcontext, void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:ga798b4ae5da79d21d0e0b1a4eb962c950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga835120bfe4726d59d13f8fbcd01fb264"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga835120bfe4726d59d13f8fbcd01fb264">drmgr_unregister_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:ga835120bfe4726d59d13f8fbcd01fb264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45210f010c66f233c8580aa1f58a294c"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga45210f010c66f233c8580aa1f58a294c">drmgr_unregister_thread_init_event_user_data</a> (void(*func)(void *drcontext, void *user_data))</td></tr>
<tr class="separator:ga45210f010c66f233c8580aa1f58a294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3e4b9d9e8cff8e8ec01ef44392cfdd"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2d3e4b9d9e8cff8e8ec01ef44392cfdd">drmgr_register_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:ga2d3e4b9d9e8cff8e8ec01ef44392cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e2e169d810174091e47364d53f18f5"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga63e2e169d810174091e47364d53f18f5">drmgr_register_thread_exit_event_ex</a> (void(*func)(void *drcontext), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga63e2e169d810174091e47364d53f18f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a0c6aabdbb08225f1d2fd605fd09f81"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2a0c6aabdbb08225f1d2fd605fd09f81">drmgr_register_thread_exit_event_user_data</a> (void(*func)(void *drcontext, void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:ga2a0c6aabdbb08225f1d2fd605fd09f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a83a4ecf1b6172eab85e116aef96bea"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga1a83a4ecf1b6172eab85e116aef96bea">drmgr_unregister_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:ga1a83a4ecf1b6172eab85e116aef96bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga587650c7772d977480861daa39911d22"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga587650c7772d977480861daa39911d22">drmgr_unregister_thread_exit_event_user_data</a> (void(*func)(void *drcontext, void *user_data))</td></tr>
<tr class="separator:ga587650c7772d977480861daa39911d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c1941a911a84b4f0ec60d2c37c6862"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gad4c1941a911a84b4f0ec60d2c37c6862">drmgr_register_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:gad4c1941a911a84b4f0ec60d2c37c6862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5afd374b143bb438d486c60bdf7cbc4e"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga5afd374b143bb438d486c60bdf7cbc4e">drmgr_register_pre_syscall_event_ex</a> (bool(*func)(void *drcontext, int sysnum), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga5afd374b143bb438d486c60bdf7cbc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78a2dccf0cfbd0f0e07b0820c735fe9"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaf78a2dccf0cfbd0f0e07b0820c735fe9">drmgr_register_pre_syscall_event_user_data</a> (bool(*func)(void *drcontext, int sysnum, void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:gaf78a2dccf0cfbd0f0e07b0820c735fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b437d862c741e995a75dc2d59ed6e43"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga7b437d862c741e995a75dc2d59ed6e43">drmgr_unregister_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:ga7b437d862c741e995a75dc2d59ed6e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762e86ccf9fc30cc82d333f436531261"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga762e86ccf9fc30cc82d333f436531261">drmgr_unregister_pre_syscall_event_user_data</a> (bool(*func)(void *drcontext, int sysnum, void *user_data))</td></tr>
<tr class="separator:ga762e86ccf9fc30cc82d333f436531261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7070ea3233d022ebf272b43a3301d130"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga7070ea3233d022ebf272b43a3301d130">drmgr_register_post_syscall_event</a> (void(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:ga7070ea3233d022ebf272b43a3301d130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06a8b25b80a61e09cacaee10b6e4ef06"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga06a8b25b80a61e09cacaee10b6e4ef06">drmgr_register_post_syscall_event_ex</a> (void(*func)(void *drcontext, int sysnum), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga06a8b25b80a61e09cacaee10b6e4ef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4de86d9bdbb6d85a05f81ec3aca1aa"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gadc4de86d9bdbb6d85a05f81ec3aca1aa">drmgr_register_post_syscall_event_user_data</a> (void(*func)(void *drcontext, int sysnum, void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:gadc4de86d9bdbb6d85a05f81ec3aca1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79da54157fa3651e28dca9a9beda358a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga79da54157fa3651e28dca9a9beda358a">drmgr_unregister_post_syscall_event</a> (void(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:ga79da54157fa3651e28dca9a9beda358a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2289eab1f61abd920c2c9e0b79d9a7c9"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2289eab1f61abd920c2c9e0b79d9a7c9">drmgr_unregister_post_syscall_event_user_data</a> (void(*func)(void *drcontext, int sysnum, void *user_data))</td></tr>
<tr class="separator:ga2289eab1f61abd920c2c9e0b79d9a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5e551a1571aca43c136a83fe334096"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaae5e551a1571aca43c136a83fe334096">drmgr_register_module_load_event</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded))</td></tr>
<tr class="separator:gaae5e551a1571aca43c136a83fe334096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14585b60c28600872f76b5e2939d638"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaa14585b60c28600872f76b5e2939d638">drmgr_register_module_load_event_ex</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:gaa14585b60c28600872f76b5e2939d638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b99b8b2501c91207ec508828c082b4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga87b99b8b2501c91207ec508828c082b4">drmgr_register_module_load_event_user_data</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded, void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:ga87b99b8b2501c91207ec508828c082b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24be0b91d19115762643898a951d986e"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga24be0b91d19115762643898a951d986e">drmgr_unregister_module_load_event</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded))</td></tr>
<tr class="separator:ga24be0b91d19115762643898a951d986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765dbfbaa6b6429ca35e2445d70badfc"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga765dbfbaa6b6429ca35e2445d70badfc">drmgr_unregister_module_load_event_user_data</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded, void *user_data))</td></tr>
<tr class="separator:ga765dbfbaa6b6429ca35e2445d70badfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e82d90a74f1f3bc87cfdaef45811c2"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga00e82d90a74f1f3bc87cfdaef45811c2">drmgr_register_module_unload_event</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info))</td></tr>
<tr class="separator:ga00e82d90a74f1f3bc87cfdaef45811c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga852887c851db019e48cf00e232cf23ef"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga852887c851db019e48cf00e232cf23ef">drmgr_register_module_unload_event_ex</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga852887c851db019e48cf00e232cf23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a8a8cd53bc9d76a453f6bfd13fc493"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga20a8a8cd53bc9d76a453f6bfd13fc493">drmgr_register_module_unload_event_user_data</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:ga20a8a8cd53bc9d76a453f6bfd13fc493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931bff986b8763df57f85b0f6cdfde58"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga931bff986b8763df57f85b0f6cdfde58">drmgr_unregister_module_unload_event</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info))</td></tr>
<tr class="separator:ga931bff986b8763df57f85b0f6cdfde58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb50301f40d7b84d7af3f7c3a4098629"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaeb50301f40d7b84d7af3f7c3a4098629">drmgr_unregister_module_unload_event_user_data</a> (void(*func)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, void *user_data))</td></tr>
<tr class="separator:gaeb50301f40d7b84d7af3f7c3a4098629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db3e75ae461dc2596d24d0768ab2716"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4db3e75ae461dc2596d24d0768ab2716">drmgr_register_kernel_xfer_event</a> (void(*func)(void *drcontext, const <a class="el" href="dr__events_8h.html#a038cff5ceca3a723b477253c5f6057bf">dr_kernel_xfer_info_t</a> *info))</td></tr>
<tr class="separator:ga4db3e75ae461dc2596d24d0768ab2716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0816f741663b1cc101449bd2cb2d8aea"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga0816f741663b1cc101449bd2cb2d8aea">drmgr_register_kernel_xfer_event_ex</a> (void(*func)(void *drcontext, const <a class="el" href="dr__events_8h.html#a038cff5ceca3a723b477253c5f6057bf">dr_kernel_xfer_info_t</a> *info), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga0816f741663b1cc101449bd2cb2d8aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c1d9997f1587ff4b690c3fc99a8244"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga05c1d9997f1587ff4b690c3fc99a8244">drmgr_unregister_kernel_xfer_event</a> (void(*func)(void *drcontext, const <a class="el" href="dr__events_8h.html#a038cff5ceca3a723b477253c5f6057bf">dr_kernel_xfer_info_t</a> *info))</td></tr>
<tr class="separator:ga05c1d9997f1587ff4b690c3fc99a8244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984ae18ed26a72c84a0fcaaaf44e2343"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga984ae18ed26a72c84a0fcaaaf44e2343">drmgr_register_signal_event</a> (<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo))</td></tr>
<tr class="separator:ga984ae18ed26a72c84a0fcaaaf44e2343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81409344987ecb2ffcf08370d4a1145d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga81409344987ecb2ffcf08370d4a1145d">drmgr_register_signal_event_ex</a> (<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga81409344987ecb2ffcf08370d4a1145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c57fb975df20d3583bb41c421f628d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga86c57fb975df20d3583bb41c421f628d">drmgr_register_signal_event_user_data</a> (<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo, void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:ga86c57fb975df20d3583bb41c421f628d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617ad3a9ed87404feb3c6afe92b81ad6"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga617ad3a9ed87404feb3c6afe92b81ad6">drmgr_unregister_signal_event</a> (<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo))</td></tr>
<tr class="separator:ga617ad3a9ed87404feb3c6afe92b81ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e39e277cba48e60006ecd5bb4cad8f"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga75e39e277cba48e60006ecd5bb4cad8f">drmgr_unregister_signal_event_user_data</a> (<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo, void *user_data))</td></tr>
<tr class="separator:ga75e39e277cba48e60006ecd5bb4cad8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd41d491993daae9eb5bc136a8971d09"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gadd41d491993daae9eb5bc136a8971d09">drmgr_register_exception_event</a> (bool(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#aa54aa75c24d4ba8dd5b8ceb2a9ba4f17">dr_exception_t</a> *excpt))</td></tr>
<tr class="separator:gadd41d491993daae9eb5bc136a8971d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf08ce7f3eab30d8c9aa0580840c569f"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gacf08ce7f3eab30d8c9aa0580840c569f">drmgr_register_exception_event_ex</a> (bool(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#aa54aa75c24d4ba8dd5b8ceb2a9ba4f17">dr_exception_t</a> *excpt), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:gacf08ce7f3eab30d8c9aa0580840c569f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga372a2681d2f9832639d5889f55132805"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga372a2681d2f9832639d5889f55132805">drmgr_unregister_exception_event</a> (bool(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#aa54aa75c24d4ba8dd5b8ceb2a9ba4f17">dr_exception_t</a> *excpt))</td></tr>
<tr class="separator:ga372a2681d2f9832639d5889f55132805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffa6aa4d9af18a42e98d15b4f82bb20"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga0ffa6aa4d9af18a42e98d15b4f82bb20">drmgr_register_restore_state_event</a> (void(*func)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent))</td></tr>
<tr class="separator:ga0ffa6aa4d9af18a42e98d15b4f82bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52f88ecf793967022bddd447c65e66f"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaf52f88ecf793967022bddd447c65e66f">drmgr_register_restore_state_ex_event</a> (bool(*func)(void *drcontext, bool restore_memory, <a class="el" href="dr__events_8h.html#a7b60f2254adf92bc99ebd248f76044fe">dr_restore_state_info_t</a> *info))</td></tr>
<tr class="separator:gaf52f88ecf793967022bddd447c65e66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbba95c12df79ff5b4ceab3c516ded92"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gabbba95c12df79ff5b4ceab3c516ded92">drmgr_register_restore_state_ex_event_ex</a> (bool(*func)(void *drcontext, bool restore_memory, <a class="el" href="dr__events_8h.html#a7b60f2254adf92bc99ebd248f76044fe">dr_restore_state_info_t</a> *info), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:gabbba95c12df79ff5b4ceab3c516ded92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55534858a00937feec337f7ca66c3c9e"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga55534858a00937feec337f7ca66c3c9e">drmgr_unregister_restore_state_event</a> (void(*func)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent))</td></tr>
<tr class="separator:ga55534858a00937feec337f7ca66c3c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f56b07ef2216961d6d01bd06bd907ec"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga5f56b07ef2216961d6d01bd06bd907ec">drmgr_unregister_restore_state_ex_event</a> (bool(*func)(void *drcontext, bool restore_memory, <a class="el" href="dr__events_8h.html#a7b60f2254adf92bc99ebd248f76044fe">dr_restore_state_info_t</a> *info))</td></tr>
<tr class="separator:ga5f56b07ef2216961d6d01bd06bd907ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga604545b4d3e296acdbfe92e0af275fcc"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga604545b4d3e296acdbfe92e0af275fcc">drmgr_register_low_on_memory_event</a> (void(*func)())</td></tr>
<tr class="separator:ga604545b4d3e296acdbfe92e0af275fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad75315837087bace296cf392abb226"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2ad75315837087bace296cf392abb226">drmgr_register_low_on_memory_event_ex</a> (void(*func)(), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority)</td></tr>
<tr class="separator:ga2ad75315837087bace296cf392abb226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266b79be2111b6300f08c3a1d6aec1f5"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga266b79be2111b6300f08c3a1d6aec1f5">drmgr_register_low_on_memory_event_user_data</a> (void(*func)(void *user_data), <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *priority, void *user_data)</td></tr>
<tr class="separator:ga266b79be2111b6300f08c3a1d6aec1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d5f9f8bf50ec7cfbc2ac1f7dff8820"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga29d5f9f8bf50ec7cfbc2ac1f7dff8820">drmgr_unregister_low_on_memory_event</a> (void(*func)())</td></tr>
<tr class="separator:ga29d5f9f8bf50ec7cfbc2ac1f7dff8820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed34155e0d54ee5464985ba8ba074d9"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga8ed34155e0d54ee5464985ba8ba074d9">drmgr_unregister_low_on_memory_event_user_data</a> (void(*func)(void *user_data))</td></tr>
<tr class="separator:ga8ed34155e0d54ee5464985ba8ba074d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada27721274b425e7b4ae5a6f5bb32d33"><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gada27721274b425e7b4ae5a6f5bb32d33">drmgr_disable_auto_predication</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist)</td></tr>
<tr class="separator:gada27721274b425e7b4ae5a6f5bb32d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0c312b9deefda685e85620ed0c7c78d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c312b9deefda685e85620ed0c7c78d5">&#9670;&nbsp;</a></span>drmgr_analysis_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* drmgr_analysis_cb_t) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, bool for_trace, bool translating, OUT void **user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for the second stage: application analysis.</p>
<p>The <code>user_data</code> parameter can be used to pass data from this stage to the third stage.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, they will be stored. </p>

</div>
</div>
<a id="gacb8f7568c015abb3c26c78983bb7c533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb8f7568c015abb3c26c78983bb7c533">&#9670;&nbsp;</a></span>drmgr_app2app_ex_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__drmgr.html#ga0c312b9deefda685e85620ed0c7c78d5">drmgr_analysis_cb_t</a> <a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for the first stage when using a user data parameter: app2app transformations on instruction list. </p>

</div>
</div>
<a id="gad4983d7847f2c744a6e19fc9537f00ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4983d7847f2c744a6e19fc9537f00ed">&#9670;&nbsp;</a></span>drmgr_ilist_ex_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* drmgr_ilist_ex_cb_t) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, bool for_trace, bool translating, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for the second, fourth, and fifth stages when using a user data parameter for all five: analysis, instru2instru, and meta_instru transformations on the whole instruction list.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, they will be stored. </p>

</div>
</div>
<a id="ga13a6681d00526e2360f2a6b13f0272aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13a6681d00526e2360f2a6b13f0272aa">&#9670;&nbsp;</a></span>drmgr_insertion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* drmgr_insertion_cb_t) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool for_trace, bool translating, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for the third stage: instrumentation insertion.</p>
<p>The <code>user_data</code> parameter contains data passed from the second stage to this stage.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, they will be stored. </p>

</div>
</div>
<a id="gaa610b2e06d4bae362405a7792b4060e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa610b2e06d4bae362405a7792b4060e3">&#9670;&nbsp;</a></span>drmgr_instru_events_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drmgr__instru__events__t.html">_drmgr_instru_events_t</a> <a class="el" href="group__drmgr.html#gaa610b2e06d4bae362405a7792b4060e3">drmgr_instru_events_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the callbacks when registering all <code>drmgr's</code> bb instrumentation events </p>

</div>
</div>
<a id="ga4895c7d1731eae3076179b3aa7364343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4895c7d1731eae3076179b3aa7364343">&#9670;&nbsp;</a></span>drmgr_opcode_insertion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* drmgr_opcode_insertion_cb_t) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool for_trace, bool translating, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for opcode based instrumentation. In particular, this callback is triggered only for specific instruction opcodes. This is done during the third stage, i.e., instrumentation insertion.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, they will be stored. </p>

</div>
</div>
<a id="gad1ea8251bfe11bcc02821ada3852e599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ea8251bfe11bcc02821ada3852e599">&#9670;&nbsp;</a></span>drmgr_priority_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drmgr__priority__t.html">_drmgr_priority_t</a> <a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the ordering of callbacks for <code>drmgr's</code> events </p>

</div>
</div>
<a id="ga1260c94e5eb2b34a7af2c2e99b129568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1260c94e5eb2b34a7af2c2e99b129568">&#9670;&nbsp;</a></span>drmgr_xform_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* drmgr_xform_cb_t) (void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *bb, bool for_trace, bool translating)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for the first, fourth, and fifth stages: app2app, instru2instru, and meta_instru transformations on the whole instruction list.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, they will be stored. </p>

</div>
</div>
<a id="gac779b3f5c1076450ad32083da0921768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac779b3f5c1076450ad32083da0921768">&#9670;&nbsp;</a></span>emulated_instr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__emulated__instr__t.html">_emulated_instr_t</a> <a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Holds data about an emulated instruction, typically populated by an emulation client and read by an observational client.</p>
<dl class="section note"><dt>Note</dt><dd>The emulated <code>instr</code> is part of the label represented by <code>emulated_instr_t</code> and as such it will be freed when the label created by <a class="el" href="group__drmgr.html#ga94b96a01f3fa0ce7ad6a5f675965d952">drmgr_insert_emulation_start()</a> is freed. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaaa131b3cd2bf8aadb9ac196911aa6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa131b3cd2bf8aadb9ac196911aa6b32">&#9670;&nbsp;</a></span>dr_emulate_options_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drmgr.html#gaaa131b3cd2bf8aadb9ac196911aa6b32">dr_emulate_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags describing different types of emulation markers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaa131b3cd2bf8aadb9ac196911aa6b32a60a60d7210d981f2fb0692e125e00dc4"></a>DR_EMULATE_REST_OF_BLOCK&#160;</td><td class="fielddoc"><p>Indicates that the entire rest of the basic block is one emulation sequence. There is no end marker, so <a class="el" href="group__drmgr.html#gaf2227473141100828d097eb98828b954">drmgr_is_emulation_end()</a> will never return true. No support is provided for traces: clients must examine the constituent blocks instead to find emulation information. This is used for emulation sequences that include a block-terminating conditional branch, indirect branch, or system call or interrupt, as DR does not allow a label to appear after such instructions. These sequences typically want to isolate their emulation to include the entire block in any case. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa131b3cd2bf8aadb9ac196911aa6b32abba41ccc153c360ffe9bf664eca14c74"></a>DR_EMULATE_IS_FIRST_INSTR&#160;</td><td class="fielddoc"><p>When used with <a class="el" href="group__drmgr.html#ga37ca9b0961ad0b562318702897df729b">drmgr_in_emulation_region()</a>, indicates that the current instruction is the first instruction of the emulation region. This allows a client to act on the original instruction just once, despite multiple emulation instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa131b3cd2bf8aadb9ac196911aa6b32a526e36749e0fb1ca4e2a00a095a42efb"></a>DR_EMULATE_INSTR_ONLY&#160;</td><td class="fielddoc"><p>Indicates that only the instruction fetch is being emulated differently. The operation of the instruction remains the same. Observational instrumentation should examine the original instruction (in <a class="el" href="struct__emulated__instr__t.html#a6ad237fed40b2d642bf959a64afbf0c5">emulated_instr_t.instr</a>) for instruction fetch purposes, but should examine the emulation sequence for data accesses (e.g., loads and stores for a memory address tracing tool). If this flag is not set, instrumentation should instrument the original instruction in every way and ignore the emulation sequence.</p>
<p>This flag is used for instruction refactorings that simplify instrumentation: e.g., <a class="el" href="group__drutil.html#gae38961d42fc285d7f9034c4b02690cae">drutil_expand_rep_string()</a> and <a class="el" href="group__drx.html#ga30c372c0385d8584660f5c449a18ec36">drx_expand_scatter_gather()</a>. It is not used for true emulation of an instruction, for example, for replacing an instruction that is not supported by the current hardware with an alternative sequence of instructions. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae3531e42d6cde87d19a63801ab6b9230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3531e42d6cde87d19a63801ab6b9230">&#9670;&nbsp;</a></span>drmgr_bb_phase_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drmgr.html#gae3531e42d6cde87d19a63801ab6b9230">drmgr_bb_phase_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Labels the current bb building phase </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae3531e42d6cde87d19a63801ab6b9230ae5168599a479256d3b95839f57e5b985"></a>DRMGR_PHASE_NONE&#160;</td><td class="fielddoc"><p>Not currently in a bb building event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3531e42d6cde87d19a63801ab6b9230a7eb5e7bcc7f6d533bcb8dcc10389441e"></a>DRMGR_PHASE_APP2APP&#160;</td><td class="fielddoc"><p>Currently in the app2app phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3531e42d6cde87d19a63801ab6b9230a242a4f07729fd4b18c296263a7308faf"></a>DRMGR_PHASE_ANALYSIS&#160;</td><td class="fielddoc"><p>Currently in the analysis phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3531e42d6cde87d19a63801ab6b9230a71f2ee3487696c6f969b06920b883dee"></a>DRMGR_PHASE_INSERTION&#160;</td><td class="fielddoc"><p>Currently in the instrumentation insertion phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3531e42d6cde87d19a63801ab6b9230ad4dab0dd27bdccf8b9d70727c9da5792"></a>DRMGR_PHASE_INSTRU2INSTRU&#160;</td><td class="fielddoc"><p>Currently in the instru2instru phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3531e42d6cde87d19a63801ab6b9230a6a18072668addf9e8197b66756d8be09"></a>DRMGR_PHASE_META_INSTRU&#160;</td><td class="fielddoc"><p>Currently in the meta-instrumentation phase. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga75f5e22831cb18cb7fbb8316cd56f09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75f5e22831cb18cb7fbb8316cd56f09f">&#9670;&nbsp;</a></span>drmgr_current_bb_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmgr.html#gae3531e42d6cde87d19a63801ab6b9230">drmgr_bb_phase_t</a> drmgr_current_bb_phase </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns which bb phase is the current one, if any.</p>
<dl class="section note"><dt>Note</dt><dd>May be called without calling <a class="el" href="group__drmgr.html#ga07ab03a2182247922f756778d18bb3fd">drmgr_init()</a> to test whether drmgr is in use. </dd></dl>

</div>
</div>
<a id="ga357735ce7daa0bb717556455f20040a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga357735ce7daa0bb717556455f20040a5">&#9670;&nbsp;</a></span>drmgr_decode_sysnum_from_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT int drmgr_decode_sysnum_from_wrapper </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a system call wrapper routine <code>entry</code> of the Native API variety, decodes the routine and returns the system call number. Returns -1 on error. </p>

</div>
</div>
<a id="gada27721274b425e7b4ae5a6f5bb32d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada27721274b425e7b4ae5a6f5bb32d33">&#9670;&nbsp;</a></span>drmgr_disable_auto_predication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_disable_auto_predication </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables auto predication globally for this basic block. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only to be used in the drmgr insertion event. </dd></dl>

</div>
</div>
<a id="ga1e27214f63289548497d25c9e628a5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e27214f63289548497d25c9e628a5d7">&#9670;&nbsp;</a></span>drmgr_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drmgr_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up the drmgr extension. </p>

</div>
</div>
<a id="ga67585e915e3f9b555ea4382ed6027812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67585e915e3f9b555ea4382ed6027812">&#9670;&nbsp;</a></span>drmgr_get_cls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drmgr_get_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user-controlled callback-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#gaba85528be6e0126b45a76245b6b4b001">drmgr_insert_read_cls_field()</a>. </p>

</div>
</div>
<a id="ga85b025c766a84bee841288d822b15380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85b025c766a84bee841288d822b15380">&#9670;&nbsp;</a></span>drmgr_get_emulated_instr_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_get_emulated_instr_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a> *&#160;</td>
          <td class="paramname"><em>emulated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads <code>emulated</code> with the emulated instruction data from <code>instr</code> set by <a class="el" href="group__drmgr.html#ga94b96a01f3fa0ce7ad6a5f675965d952">drmgr_insert_emulation_start()</a>.</p>
<p>When calling this function, the <code>size</code> field of <code>emulated</code> should be set using sizeof(). This allows the API to check for compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instr</td><td>The label instruction which specifies start of emulation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">emulated</td><td>The emulated instruction data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the caller's <code>emulated_instr_t</code> is not compatible, true otherwise. </dd></dl>

</div>
</div>
<a id="ga4f53520da678e84fd7712e2fcca0182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f53520da678e84fd7712e2fcca0182b">&#9670;&nbsp;</a></span>drmgr_get_parent_cls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drmgr_get_parent_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user-controlled callback-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>, for the parent context (i.e., the context most recently pushed either by a Windows callback entry or a call to <a class="el" href="group__drmgr.html#gae2a70abba090ee410babc6a1548bb21d">drmgr_push_cls()</a>). If there is no parent context, returns NULL. </p>

</div>
</div>
<a id="gade57b8de9ed73d579044aa8f12abfe8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade57b8de9ed73d579044aa8f12abfe8d">&#9670;&nbsp;</a></span>drmgr_get_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drmgr_get_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user-controlled thread-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga512b4290d94b1874537e5b604cb27cab">drmgr_register_tls_field()</a>. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#ga7c72a35608998e6e359a3a652a7f97f7">drmgr_insert_read_tls_field()</a>. </p>

</div>
</div>
<a id="ga37ca9b0961ad0b562318702897df729b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ca9b0961ad0b562318702897df729b">&#9670;&nbsp;</a></span>drmgr_in_emulation_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_in_emulation_region </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT const <a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a> **&#160;</td>
          <td class="paramname"><em>emulation_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called during drmgr's insertion phase. Returns whether the current instruction in the phase is inside an emulation region. If it returns true, <code>emulation_info</code> is written with a pointer to information about the emulation. The pointed-at information's lifetime is the full range of the emulation region.</p>
<p>This is a convenience routine that records the state for the <a class="el" href="group__drmgr.html#gae4a20b19e779581dccac41eca9bf8321">drmgr_is_emulation_start()</a> and <a class="el" href="group__drmgr.html#gaf2227473141100828d097eb98828b954">drmgr_is_emulation_end()</a> labels and the <a class="el" href="group__drmgr.html#ggaaa131b3cd2bf8aadb9ac196911aa6b32a60a60d7210d981f2fb0692e125e00dc4">DR_EMULATE_REST_OF_BLOCK</a> flag to prevent the client having to store state.</p>
<p>While this is exported, there is still complexity in analyzing the different flags, and we recommend that clients do not use this function directly but instead use the two routines <a class="el" href="group__drmgr.html#gad375fb1c1a8683c54a78f4f5b9951f4a">drmgr_orig_app_instr_for_fetch()</a> and <a class="el" href="group__drmgr.html#ga6373ac13132abb039c7d0593bde073ba">drmgr_orig_app_instr_for_operands()</a> (which internally use this function):</p>
<p>dr_emit_flags_t event_insertion(void *drcontext, void *tag, instrlist_t *bb, <a class="el" href="structinstr__t.html">instr_t</a> *insert_instr, bool for_trace, bool translating, void *user_data) { <a class="el" href="structinstr__t.html">instr_t</a> *instr_fetch = drmgr_orig_app_instr_for_fetch(drcontext); if (instr_fetch != NULL) record_instr_fetch(instr_fetch); <a class="el" href="structinstr__t.html">instr_t</a> *instr_operands = drmgr_orig_app_instr_for_operands(drcontext); if (instr_operands_valid != NULL) record_data_addresses(instr_operands); return DR_EMIT_DEFAULT; }</p>
<dl class="section return"><dt>Returns</dt><dd>false if the caller's <code>emulated_instr_t</code> is not compatible, true otherwise. </dd></dl>

</div>
</div>
<a id="ga07ab03a2182247922f756778d18bb3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ab03a2182247922f756778d18bb3fd">&#9670;&nbsp;</a></span>drmgr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the drmgr extension. Must be called prior to any of the other routines. Can be called multiple times (by separate components, normally) but each call must be paired with a corresponding call to <a class="el" href="group__drmgr.html#ga1e27214f63289548497d25c9e628a5d7">drmgr_exit()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga2f7dd031774c812d485d4910846fbb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7dd031774c812d485d4910846fbb73">&#9670;&nbsp;</a></span>drmgr_insert_emulation_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drmgr_insert_emulation_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a label into <code>ilist</code> prior to <code>where</code> to indicate the end of a sequence of instructions emulating an instruction, preceded by a label created with <a class="el" href="group__drmgr.html#ga94b96a01f3fa0ce7ad6a5f675965d952">drmgr_insert_emulation_start()</a>. Alternatively, <a class="el" href="group__drmgr.html#ggaaa131b3cd2bf8aadb9ac196911aa6b32a60a60d7210d981f2fb0692e125e00dc4">DR_EMULATE_REST_OF_BLOCK</a> can be used on the start label to include the entire block, with no need for an end label. </p>

</div>
</div>
<a id="ga94b96a01f3fa0ce7ad6a5f675965d952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94b96a01f3fa0ce7ad6a5f675965d952">&#9670;&nbsp;</a></span>drmgr_insert_emulation_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_emulation_start </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gac779b3f5c1076450ad32083da0921768">emulated_instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a label into <code>ilist</code> prior to <code>where</code> to indicate the start of a sequence of instructions emulating an instruction <code>instr</code>. The label has data attached which describes the instruction being emulated.</p>
<p>A label will also appear at the end of the sequence, added using <a class="el" href="group__drmgr.html#ga2f7dd031774c812d485d4910846fbb73">drmgr_insert_emulation_end()</a> (unless <a class="el" href="group__drmgr.html#ggaaa131b3cd2bf8aadb9ac196911aa6b32a60a60d7210d981f2fb0692e125e00dc4">DR_EMULATE_REST_OF_BLOCK</a> is set). These start and stop labels can be detected by an observational client using <a class="el" href="group__drmgr.html#gae4a20b19e779581dccac41eca9bf8321">drmgr_is_emulation_start()</a> and <a class="el" href="group__drmgr.html#gaf2227473141100828d097eb98828b954">drmgr_is_emulation_end()</a> allowing the client to distinguish between native app instructions and instructions used for emulation.</p>
<p>When calling this function, the <code>size</code> field of <code>instr</code> should be set using sizeof(). This allows the API to check for compatibility.</p>
<p>Information about the instruction being emulated can be read from the label using <a class="el" href="group__drmgr.html#ga85b025c766a84bee841288d822b15380">drmgr_get_emulated_instr_data()</a>.</p>
<p>If label callbacks are used, please note that the callback will not be cloned and its use is currently not consistent (xref i#3962).</p>
<dl class="section return"><dt>Returns</dt><dd>false if the caller's <code>emulated_instr_t</code> is not compatible, true otherwise. </dd></dl>

</div>
</div>
<a id="gaba85528be6e0126b45a76245b6b4b001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba85528be6e0126b45a76245b6b4b001">&#9670;&nbsp;</a></span>drmgr_insert_read_cls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_read_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for the current (at execution time) callback and index. Reads from the same field as <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga7c72a35608998e6e359a3a652a7f97f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c72a35608998e6e359a3a652a7f97f7">&#9670;&nbsp;</a></span>drmgr_insert_read_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_read_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for this thread and index. Reads from the same field as <a class="el" href="group__drmgr.html#gade57b8de9ed73d579044aa8f12abfe8d">drmgr_get_tls_field()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gaa1d2757949d817bae787612177c00d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d2757949d817bae787612177c00d85">&#9670;&nbsp;</a></span>drmgr_insert_write_cls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_write_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>scratch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for the current (at execution time) callback and index. Writes to the same field as <a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field()</a>. The register <code>scratch</code> will be overwritten. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga65e2ae3d0f058fb069db7969e390c881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e2ae3d0f058fb069db7969e390c881">&#9670;&nbsp;</a></span>drmgr_insert_write_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_write_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>scratch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for this thread and index. Writes to the same field as <a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field()</a>. The register <code>scratch</code> will be overwritten. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gaf2227473141100828d097eb98828b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2227473141100828d097eb98828b954">&#9670;&nbsp;</a></span>drmgr_is_emulation_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_is_emulation_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the instruction <code>instr</code> to see if it is an emulation end label created by <a class="el" href="group__drmgr.html#ga2f7dd031774c812d485d4910846fbb73">drmgr_insert_emulation_end()</a>. Typically used in an instrumentation client running with an emulation client.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <code>instr</code> is an emulation end label, false otherwise. </dd></dl>

</div>
</div>
<a id="gae4a20b19e779581dccac41eca9bf8321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4a20b19e779581dccac41eca9bf8321">&#9670;&nbsp;</a></span>drmgr_is_emulation_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_is_emulation_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the instruction <code>instr</code> to see if it is an emulation start label created by <a class="el" href="group__drmgr.html#ga94b96a01f3fa0ce7ad6a5f675965d952">drmgr_insert_emulation_start()</a>. Typically used in an instrumentation client running with an emulation client.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <code>instr</code> is an emulation start label, false otherwise. </dd></dl>

</div>
</div>
<a id="gadd8688fd6cc4d7e1f804ccd1460f5177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd8688fd6cc4d7e1f804ccd1460f5177">&#9670;&nbsp;</a></span>drmgr_is_first_instr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_is_first_instr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called during drmgr's insertion phase. Returns whether <code>instr</code> is the first instruction (of any type) in the instruction list (as of immediately after the analysis phase). </p>

</div>
</div>
<a id="ga6d7f56824be0f6b04d5b6353f0681d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d7f56824be0f6b04d5b6353f0681d70">&#9670;&nbsp;</a></span>drmgr_is_first_nonlabel_instr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_is_first_nonlabel_instr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called during drmgr's insertion phase. Returns whether <code>instr</code> is the first non-label instruction in the instruction list (as of immediately after the analysis phase). </p>

</div>
</div>
<a id="ga60452df11f634ad4633578ba5330d2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60452df11f634ad4633578ba5330d2c4">&#9670;&nbsp;</a></span>drmgr_is_last_instr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_is_last_instr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called during drmgr's insertion phase. Returns whether <code>instr</code> is the last instruction (of any type) in the instruction list (as of immediately after the analysis phase). </p>

</div>
</div>
<a id="gad375fb1c1a8683c54a78f4f5b9951f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad375fb1c1a8683c54a78f4f5b9951f4a">&#9670;&nbsp;</a></span>drmgr_orig_app_instr_for_fetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="structinstr__t.html">instr_t</a>* drmgr_orig_app_instr_for_fetch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called during drmgr's insertion phase.</p>
<p>Returns the instruction to consider as the current application instruction for observational clients with respect to which instruction is executed, taking into account emulation. This may be different from the current instruction list instruction passed to the insertion event.</p>
<p>Returns NULL if observational clients should skip the current instruction list instruction. </p>

</div>
</div>
<a id="ga6373ac13132abb039c7d0593bde073ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6373ac13132abb039c7d0593bde073ba">&#9670;&nbsp;</a></span>drmgr_orig_app_instr_for_operands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="structinstr__t.html">instr_t</a>* drmgr_orig_app_instr_for_operands </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called during drmgr's insertion phase.</p>
<p>Returns the instruction to consider as the current application instruction for observational clients with respect to the operands of the instruction, taking into account emulation. This may be different from the current instruction list instruction passed to the insertion event.</p>
<p>Returns NULL if observational clients should skip the current instruction list instruction. </p>

</div>
</div>
<a id="ga4ac55faa0a4274ab5d8ac1cbd247b569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ac55faa0a4274ab5d8ac1cbd247b569">&#9670;&nbsp;</a></span>drmgr_pop_cls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_pop_cls </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops a callback context from the callback-local storage (cls) context stack for the given thread. This function is automatically called on exit from a Windows callback. Users can invoke it to provide context stacks for their own uses, including Linux signals or layered wrapped functions. Invoking this function will trigger the <code>cb_exit_func</code> passed to <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>.</p>
<p>Returns false if the context stack has only one entry. </p>

</div>
</div>
<a id="gae2a70abba090ee410babc6a1548bb21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a70abba090ee410babc6a1548bb21d">&#9670;&nbsp;</a></span>drmgr_push_cls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_push_cls </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a new callback context onto the callback-local storage (cls) context stack for the given thread. This function is automatically called on entry to a new Windows callback. Users can invoke it to provide context stacks for their own uses, including Linux signals or layered wrapped functions. Invoking this function will trigger the <code>cb_init_func</code> passed to <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gae270eeb1ab24d4e05f8588b23822f45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae270eeb1ab24d4e05f8588b23822f45c">&#9670;&nbsp;</a></span>drmgr_register_bb_app2app_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_app2app_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the first instrumentation stage: application-to-application ("app2app") transformations on each basic block. drmgr will call <code>func</code> as the first of five instrumentation stages for each dynamic application basic block. Examples of app2app transformations include replacing one function with another or replacing one instruction with another throughout an application.</p>
<p>The app2app passes are allowed to modify and insert non-meta (i.e., application) instructions and are intended for application code transformations. These passes should avoid adding meta instructions other than label instructions.</p>
<p>All instrumentation must follow the guidelines for <a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a> with the exception that multiple application control transfer instructions are supported so long as all but one have intra-block <code><a class="el" href="structinstr__t.html">instr_t</a></code> targets. This is to support internal control flow that may be necessary for some application-to-application transformations. These control transfer instructions should have a translation set so that later passes know which application address they correspond to. <code>drmgr</code> will mark all of the extra non-meta control transfers as meta, and clear their translation fields, right before passing to DynamoRIO, in order to satisfy DynamoRIO's constraints. This allows all of the instrumentation passes to see these instructions as application instructions, which is how they should be treated.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the given priority request cannot be satisfied (e.g., <code>priority-&gt;before</code> is already ordered after <code>priority-&gt;after</code>) or the given name is already taken.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callback to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Specifies the relative ordering of the callback. Can be NULL, in which case a default priority is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f1f4cb66a41c81a12a8b37ba96083de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f1f4cb66a41c81a12a8b37ba96083de">&#9670;&nbsp;</a></span>drmgr_register_bb_instru2instru_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_instru2instru_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the fourth instrumentation stage: instrumentation-to-instrumentation transformations on each basic block. drmgr will call <code>func</code> as the fourth of five instrumentation stages for each dynamic application basic block. Instrumentation-to-instrumentation passes are allowed to insert meta instructions but not non-meta instructions, and are intended for optimization of prior instrumentation passes.</p>
<p>All instrumentation must follow the guidelines for <a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the given priority request cannot be satisfied (e.g., <code>priority-&gt;before</code> is already ordered after <code>priority-&gt;after</code>) or the given name is already taken.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callback to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Specifies the relative ordering of the callback. Can be NULL, in which case a default priority is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4917fd1c3d667e52fc77b48d1325d85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4917fd1c3d667e52fc77b48d1325d85b">&#9670;&nbsp;</a></span>drmgr_register_bb_instrumentation_all_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_instrumentation_all_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gaa610b2e06d4bae362405a7792b4060e3">drmgr_instru_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers callbacks for all five instrumentation passes at once, with a <code>user_data</code> parameter passed among them all, enabling data sharing for all five of them. See the documentation for <a class="el" href="group__drmgr.html#gae270eeb1ab24d4e05f8588b23822f45c">drmgr_register_bb_app2app_event()</a>, <a class="el" href="group__drmgr.html#ga83a5fc96944e10bd7356e0c492c93966">drmgr_register_bb_instrumentation_event()</a>, <a class="el" href="group__drmgr.html#ga2f1f4cb66a41c81a12a8b37ba96083de">drmgr_register_bb_instru2instru_event()</a>, and <a class="el" href="group__drmgr.html#ga8d3c4cfcbfe46adcaa51efc12be8eafc">drmgr_register_bb_meta_instru_event()</a> for further details of each pass. The aforementioned routines are identical to this with the exception of the extra <code>user_data</code> parameter, which is an OUT parameter to the <code>app2app_func</code> and passed in to the four subsequent callbacks. The <code>priority</code> param can be NULL, in which case a default priority is used. </p>

</div>
</div>
<a id="ga83a5fc96944e10bd7356e0c492c93966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a5fc96944e10bd7356e0c492c93966">&#9670;&nbsp;</a></span>drmgr_register_bb_instrumentation_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_instrumentation_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga0c312b9deefda685e85620ed0c7c78d5">drmgr_analysis_cb_t</a>&#160;</td>
          <td class="paramname"><em>analysis_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a>&#160;</td>
          <td class="paramname"><em>insertion_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers callback functions for the second and third instrumentation stages: application analysis and instrumentation insertion. drmgr will call <code>func</code> as the second of five instrumentation stages for each dynamic application basic block.</p>
<p>The first stage performed any changes to the original application code, and later stages are not allowed to change application code. Application analysis passes in the second stage are not allowed to add to or change the instruction list other than adding label instructions, and are intended for analysis of application code either for immediate use or for use by the third stage. Label instructions can be used to store data for use in subsequent stages with custom tags inserted as notes via <a class="el" href="group__drmgr.html#ga057f980fa9323a0bb8a4226c7c52c14a">drmgr_reserve_note_range()</a> and custom data stored via <a class="el" href="dr__ir__instr_8h.html#a946303e1c9c3d1102603dc9842479b0c">instr_get_label_data_area()</a>.</p>
<p>The third instrumentation stage is instrumentation insertion. Unlike the other stages, this one passes only one instruction to the callback, allowing each registered component to act on one instruction before moving to the next instruction. Instrumentation insertion passes are allowed to insert meta instructions only immediately prior to the passed-in instruction: not before any prior non-meta instruction nor after any subsequent non-meta instruction. They are not allowed to insert new non-meta instructions or change existing non-meta instructions. Because other components may have already acted on the instruction list, be sure to ignore already existing meta instructions.</p>
<p>The <code>analysis_func</code> and <code>insertion_func</code> share the same priority. Their user_data parameter can be used to pass data from the analysis stage to the insertion stage.</p>
<p>All instrumentation must follow the guidelines for <a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a>.</p>
<p>On ARM, for the instrumentation insertion event, drmgr does not set the predicate for all meta instructions inserted by each callback to match the predicate of the corresponding application instruction. It is the client's responsibility to set proper predicates for all meta instructions. At the end of all instrumentation stages, drmgr automatically adds enough IT instructions to create legal IT blocks in Thumb mode.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the given priority request cannot be satisfied (e.g., <code>priority-&gt;before</code> is already ordered after <code>priority-&gt;after</code>) or the given name is already taken.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">analysis_func</td><td>The analysis callback to be called for the second stage. Can be NULL if insertion_func is non-NULL, in which case the user_data passed to insertion_func is NULL and <a class="el" href="group__drmgr.html#ga85890ca6d143f6a5218680484a25d3fb">drmgr_unregister_bb_insertion_event()</a> must be used to unregister. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertion_func</td><td>The insertion callback to be called for the third stage. Can be NULL if analysis_func is non-NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Specifies the relative ordering of both callbacks. Can be NULL, in which case a default priority is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is possible for meta instructions to be present and passed to the analysis and/or insertion stages, if they were added in the app2app or analysis stages. While this is discouraged, it is sometimes unavoidable, such as for <a class="el" href="group__drwrap.html#ga0ae2e383b0005a46848c7d0497be563a">drwrap_replace_native()</a>. We recommend that all instrumentation stages check for meta instructions (and ignore them, typically). </dd></dl>

</div>
</div>
<a id="ga26e4be9f62ffd954f2f95ba21ec92953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e4be9f62ffd954f2f95ba21ec92953">&#9670;&nbsp;</a></span>drmgr_register_bb_instrumentation_ex_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_instrumentation_ex_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a>&#160;</td>
          <td class="paramname"><em>app2app_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a>&#160;</td>
          <td class="paramname"><em>analysis_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a>&#160;</td>
          <td class="paramname"><em>insertion_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a>&#160;</td>
          <td class="paramname"><em>instru2instru_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers callbacks for the first four instrumentation passes at once, with a <code>user_data</code> parameter passed among them all, enabling data sharing for all four of them. See the documentation for <a class="el" href="group__drmgr.html#gae270eeb1ab24d4e05f8588b23822f45c">drmgr_register_bb_app2app_event()</a>, <a class="el" href="group__drmgr.html#ga83a5fc96944e10bd7356e0c492c93966">drmgr_register_bb_instrumentation_event()</a>, and <a class="el" href="group__drmgr.html#ga2f1f4cb66a41c81a12a8b37ba96083de">drmgr_register_bb_instru2instru_event()</a> for further details of each pass. The aforementioned routines are identical to this with the exception of the extra <code>user_data</code> parameter, which is an OUT parameter to the <code>app2app_func</code> and passed in to the three subsequent callbacks. The <code>priority</code> param can be NULL, in which case a default priority is used. </p>

</div>
</div>
<a id="ga8d3c4cfcbfe46adcaa51efc12be8eafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d3c4cfcbfe46adcaa51efc12be8eafc">&#9670;&nbsp;</a></span>drmgr_register_bb_meta_instru_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_meta_instru_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the fifth instrumentation stage: meta-instrumentation analysis and transformations on each basic block. drmgr will call <code>func</code> as the fifth of five instrumentation stages for each dynamic application basic block. Meta-instrumentation passes are allowed to insert both meta and non-meta instructions, and are primarily intended for debugging prior instrumentation passes.</p>
<p>All instrumentation must follow the guidelines for <a class="el" href="dr__events_8h.html#acbfe1ece2c520d409ffd59076507a710">dr_register_bb_event()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the given priority request cannot be satisfied (e.g., <code>priority-&gt;before</code> is already ordered after <code>priority-&gt;after</code>) or the given name is already taken.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callback to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Specifies the relative ordering of the callback. Can be NULL, in which case a default priority is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga933ff32be874004447af771283d0bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga933ff32be874004447af771283d0bcee">&#9670;&nbsp;</a></span>drmgr_register_cls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT int drmgr_register_cls_field </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, bool new_depth)&#160;</td>
          <td class="paramname"><em>cb_init_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, bool thread_exit)&#160;</td>
          <td class="paramname"><em>cb_exit_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves a callback-local storage (cls) slot. Thread-local storage (tls) is callback-shared. Callbacks interrupt thread execution to execute arbitrary amounts of code in a new context before returning to the interrupted context. Thread-local storage fields that persist across application execution can be overwritten during callback execution, resulting in incorrect values when returning to the original context. Callback-local storage, rather than thread-local storage, should be used for any fields that store information specific to the application's execution.</p>
<p>Returns the index of the slot, which should be passed to <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a> and <a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field()</a>. Returns -1 if there are no more slots available.</p>
<p>Callbacks are frequent, but normally the stack of callback contexts is only a few entries deep. It is most efficient to re-use cls data from prior callbacks, only allocating new memory when entering a new context stack depth. The <code>cb_init_func</code> parameter is invoked on each new callback context, with <code>new_depth</code> set to true only when entering a new callback context stack depth. When <code>new_depth</code> is false, <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a> will return the value set at that depth the last time it was reached, and the client would normally not need to allocate memory but would only need to initialize it. When <code>new_depth</code> is true, <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a> will return NULL, and the user should use <a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field()</a> to initialize the slot itself as well as whatever it points to.</p>
<p>Similarly, normal usage should ignore <code>cb_exit_func</code> unless it is called with <code>thread_exit</code> set to true, in which case any memory in the cls slot should be de-allocated.</p>
<p>Callbacks are Windows-specific. The cls interfaces are not marked for Windows-only, however, to facilitate cross-platform code. We recommend that cross-plaform code be written using cls fields on both platforms; the fields on Linux will never be stacked and will function as tls fields. Technically the same context interruption can occur with a Linux signal, but Linux signals typically execute small amounts of code and avoid making stateful changes; furthermore, there is no guaranteed end point to a signal. The <a class="el" href="group__drmgr.html#gae2a70abba090ee410babc6a1548bb21d">drmgr_push_cls()</a> and <a class="el" href="group__drmgr.html#ga4ac55faa0a4274ab5d8ac1cbd247b569">drmgr_pop_cls()</a> interface can be used to provide a stack of contexts on Linux, or to provide a stack of contexts for any other purpose such as layered wrapped functions. These push and pop functions are automatically called on Windows callback entry and exit, with the push called in DR's kernel xfer event prior to any client callback for that event, and pop called in the same event but after any client callback. </p>

</div>
</div>
<a id="gadd41d491993daae9eb5bc136a8971d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd41d491993daae9eb5bc136a8971d09">&#9670;&nbsp;</a></span>drmgr_register_exception_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_exception_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, <a class="el" href="dr__events_8h.html#aa54aa75c24d4ba8dd5b8ceb2a9ba4f17">dr_exception_t</a> *excpt)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the exception event, which behaves just like DR's exception event <a class="el" href="dr__events_8h.html#a36fc1b4f973393d861c7740cda6c0002">dr_register_exception_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gacf08ce7f3eab30d8c9aa0580840c569f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf08ce7f3eab30d8c9aa0580840c569f">&#9670;&nbsp;</a></span>drmgr_register_exception_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_exception_event_ex </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, <a class="el" href="dr__events_8h.html#aa54aa75c24d4ba8dd5b8ceb2a9ba4f17">dr_exception_t</a> *excpt)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the exception event, which behaves just like DR's exception event <a class="el" href="dr__events_8h.html#a36fc1b4f973393d861c7740cda6c0002">dr_register_exception_event()</a>, except that it is ordered according to <code>priority</code>. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#gadd41d491993daae9eb5bc136a8971d09">drmgr_register_exception_event()</a>. Just like for DR, the first callback to return false will short-circuit event delivery to later callbacks. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga4db3e75ae461dc2596d24d0768ab2716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4db3e75ae461dc2596d24d0768ab2716">&#9670;&nbsp;</a></span>drmgr_register_kernel_xfer_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_kernel_xfer_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__events_8h.html#a038cff5ceca3a723b477253c5f6057bf">dr_kernel_xfer_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the kernel transfer event, which behaves just like DR's kernel transfer event <a class="el" href="dr__events_8h.html#ac433abf2a9b5ec9a5571e39d7d069df2">dr_register_kernel_xfer_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga0816f741663b1cc101449bd2cb2d8aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0816f741663b1cc101449bd2cb2d8aea">&#9670;&nbsp;</a></span>drmgr_register_kernel_xfer_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_kernel_xfer_event_ex </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__events_8h.html#a038cff5ceca3a723b477253c5f6057bf">dr_kernel_xfer_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the kernel transfer event, which behaves just like DR's kernel transfer event <a class="el" href="dr__events_8h.html#ac433abf2a9b5ec9a5571e39d7d069df2">dr_register_kernel_xfer_event()</a>, except that it is ordered according to <code>priority</code>. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#ga00e82d90a74f1f3bc87cfdaef45811c2">drmgr_register_module_unload_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga604545b4d3e296acdbfe92e0af275fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga604545b4d3e296acdbfe92e0af275fcc">&#9670;&nbsp;</a></span>drmgr_register_low_on_memory_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_low_on_memory_event </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function <code>func</code> for the low-on-memory event. The callback provides a means for the client to free any non-critical data found on the heap, which could avoid a potential out-of-memory crash (particularly on 32-bit). </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga2ad75315837087bace296cf392abb226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad75315837087bace296cf392abb226">&#9670;&nbsp;</a></span>drmgr_register_low_on_memory_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_low_on_memory_event_ex </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function <code>func</code> for the low-on-memory event just like <a class="el" href="group__drmgr.html#ga604545b4d3e296acdbfe92e0af275fcc">drmgr_register_low_on_memory_event()</a>, but the callback is prioritised according to <code>priority</code>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga266b79be2111b6300f08c3a1d6aec1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga266b79be2111b6300f08c3a1d6aec1f5">&#9670;&nbsp;</a></span>drmgr_register_low_on_memory_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_low_on_memory_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function <code>func</code> for the low-on-memory event just like <a class="el" href="group__drmgr.html#ga604545b4d3e296acdbfe92e0af275fcc">drmgr_register_low_on_memory_event()</a>, but allows the passing of user data <code>user_data</code>. The callback is prioritised according to <code>priority</code>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gaae5e551a1571aca43c136a83fe334096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae5e551a1571aca43c136a83fe334096">&#9670;&nbsp;</a></span>drmgr_register_module_load_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_module_load_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module load event, which behaves just like DR's module load event <a class="el" href="dr__events_8h.html#a004acbc467ec57cd62be8c49d57a6928">dr_register_module_load_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gaa14585b60c28600872f76b5e2939d638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa14585b60c28600872f76b5e2939d638">&#9670;&nbsp;</a></span>drmgr_register_module_load_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_module_load_event_ex </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module load event, which behaves just like DR's module load event <a class="el" href="dr__events_8h.html#a004acbc467ec57cd62be8c49d57a6928">dr_register_module_load_event()</a>, except that it is ordered according to <code>priority</code>. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#gaae5e551a1571aca43c136a83fe334096">drmgr_register_module_load_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga87b99b8b2501c91207ec508828c082b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b99b8b2501c91207ec508828c082b4">&#9670;&nbsp;</a></span>drmgr_register_module_load_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_module_load_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module load event, which behaves just like DR's module load event <a class="el" href="dr__events_8h.html#a004acbc467ec57cd62be8c49d57a6928">dr_register_module_load_event()</a>. Allows for the passing of user input <code>user_data</code>, which is available upon the execution of the callback. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#gaa14585b60c28600872f76b5e2939d638">drmgr_register_module_load_event_ex()</a>. </p>

</div>
</div>
<a id="ga00e82d90a74f1f3bc87cfdaef45811c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e82d90a74f1f3bc87cfdaef45811c2">&#9670;&nbsp;</a></span>drmgr_register_module_unload_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_module_unload_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module unload event, which behaves just like DR's module unload event <a class="el" href="dr__events_8h.html#a1f11f7dd3d5509289049a8f996a60ca1">dr_register_module_unload_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga852887c851db019e48cf00e232cf23ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga852887c851db019e48cf00e232cf23ef">&#9670;&nbsp;</a></span>drmgr_register_module_unload_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_module_unload_event_ex </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module unload event, which behaves just like DR's module unload event <a class="el" href="dr__events_8h.html#a1f11f7dd3d5509289049a8f996a60ca1">dr_register_module_unload_event()</a>, except that it is ordered according to <code>priority</code>. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#ga00e82d90a74f1f3bc87cfdaef45811c2">drmgr_register_module_unload_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga20a8a8cd53bc9d76a453f6bfd13fc493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a8a8cd53bc9d76a453f6bfd13fc493">&#9670;&nbsp;</a></span>drmgr_register_module_unload_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_module_unload_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module unload event, which behaves just like DR's module unload event <a class="el" href="dr__events_8h.html#a1f11f7dd3d5509289049a8f996a60ca1">dr_register_module_unload_event()</a>. Allows for the passing of user data, <code>user_data</code>, which is available upon the execution of the callback. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga852887c851db019e48cf00e232cf23ef">drmgr_register_module_unload_event_ex()</a>. </p>

</div>
</div>
<a id="ga14834254df9e9ded4369063e5cfba909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14834254df9e9ded4369063e5cfba909">&#9670;&nbsp;</a></span>drmgr_register_opcode_instrumentation_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_opcode_instrumentation_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga4895c7d1731eae3076179b3aa7364343">drmgr_opcode_insertion_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers callback functions for the third instrumentation stage: instrumentation insertion. drmgr will call <code>func</code> for each instruction with the specific opcode <code>opcode</code>.</p>
<p>More than one callback function can be mapped to the same opcode. Their execution sequence is determined by their priority <code>priority</code> (if set). Ordering based on priority is also taken into account with respect to insert per instr events.</p>
<p>Since this callback is triggered during instrumentation insertion, same usage rules apply. The callback is allowed to insert meta instructions only immediately prior to the passed-in instruction. New non-meta instructions cannot be inserted.</p>
<dl class="section return"><dt>Returns</dt><dd>false upon failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The opcode insertion callback to be called for the third stage for a specific opcode instruction. Cannot be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>The opcode to associate with the insertion callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Specifies the relative ordering of both callbacks. Can be NULL, in which case a default priority is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data made available when triggering the callback <code>func</code>. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is possible that this callback will be triggered for meta instructions. Therefore, we recommend that the callback check for meta instructions (and ignore them, typically). </dd></dl>

</div>
</div>
<a id="ga7070ea3233d022ebf272b43a3301d130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7070ea3233d022ebf272b43a3301d130">&#9670;&nbsp;</a></span>drmgr_register_post_syscall_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_post_syscall_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the post-syscall event, which behaves just like DR's post-syscall event <a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga06a8b25b80a61e09cacaee10b6e4ef06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06a8b25b80a61e09cacaee10b6e4ef06">&#9670;&nbsp;</a></span>drmgr_register_post_syscall_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_post_syscall_event_ex </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the post-syscall event, which behaves just like DR's post-syscall event <a class="el" href="dr__events_8h.html#a7a62b6c11f3b0ae2fe7773189f6e4826">dr_register_post_syscall_event()</a>, except that it is ordered according to <code>priority</code>. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#ga7070ea3233d022ebf272b43a3301d130">drmgr_register_post_syscall_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gadc4de86d9bdbb6d85a05f81ec3aca1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc4de86d9bdbb6d85a05f81ec3aca1aa">&#9670;&nbsp;</a></span>drmgr_register_post_syscall_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_post_syscall_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the post-syscall event, ordered by <code>priority</code>. Allows for the passing of user data <code>user_data</code> which is available upon the execution of the callback. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga06a8b25b80a61e09cacaee10b6e4ef06">drmgr_register_post_syscall_event_ex()</a>. </p>

</div>
</div>
<a id="gad4c1941a911a84b4f0ec60d2c37c6862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4c1941a911a84b4f0ec60d2c37c6862">&#9670;&nbsp;</a></span>drmgr_register_pre_syscall_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_pre_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the pre-syscall event, which behaves just like DR's pre-syscall event <a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>. In particular, a filter event is still needed to ensure that a pre- or post-syscall event is actually called: use <a class="el" href="dr__events_8h.html#a1f98fd4c247abe6c7fcc6d02291b44de">dr_register_filter_syscall_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga5afd374b143bb438d486c60bdf7cbc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5afd374b143bb438d486c60bdf7cbc4e">&#9670;&nbsp;</a></span>drmgr_register_pre_syscall_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_pre_syscall_event_ex </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the pre-syscall event, which behaves just like DR's pre-syscall event <a class="el" href="dr__events_8h.html#a80d0f026def74d903a83fb6122816ae2">dr_register_pre_syscall_event()</a>, except that it is ordered according to <code>priority</code>. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#gad4c1941a911a84b4f0ec60d2c37c6862">drmgr_register_pre_syscall_event()</a>. A filter event is still needed to ensure that a pre- or post-syscall event is actually called: use <a class="el" href="dr__events_8h.html#a1f98fd4c247abe6c7fcc6d02291b44de">dr_register_filter_syscall_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gaf78a2dccf0cfbd0f0e07b0820c735fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf78a2dccf0cfbd0f0e07b0820c735fe9">&#9670;&nbsp;</a></span>drmgr_register_pre_syscall_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_pre_syscall_event_user_data </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the pre-syscall event, ordered by <code>priority</code>. Allows for the passing of user data <code>user_data</code> which is available upon the execution of the callback. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga5afd374b143bb438d486c60bdf7cbc4e">drmgr_register_pre_syscall_event_ex()</a>. </p>

</div>
</div>
<a id="ga0ffa6aa4d9af18a42e98d15b4f82bb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ffa6aa4d9af18a42e98d15b4f82bb20">&#9670;&nbsp;</a></span>drmgr_register_restore_state_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_restore_state_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the restore state event, which behaves just like DR's restore state event <a class="el" href="dr__events_8h.html#a46dc6ae264b5b293e889cc88ea808eab">dr_register_restore_state_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gaf52f88ecf793967022bddd447c65e66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf52f88ecf793967022bddd447c65e66f">&#9670;&nbsp;</a></span>drmgr_register_restore_state_ex_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_restore_state_ex_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, bool restore_memory, <a class="el" href="dr__events_8h.html#a7b60f2254adf92bc99ebd248f76044fe">dr_restore_state_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the restore state extended event, which behaves just like DR's restore state event <a class="el" href="dr__events_8h.html#a89881448b9890f44ef26eab71014e956">dr_register_restore_state_ex_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gabbba95c12df79ff5b4ceab3c516ded92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbba95c12df79ff5b4ceab3c516ded92">&#9670;&nbsp;</a></span>drmgr_register_restore_state_ex_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_restore_state_ex_event_ex </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, bool restore_memory, <a class="el" href="dr__events_8h.html#a7b60f2254adf92bc99ebd248f76044fe">dr_restore_state_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the restore state extended event, which behaves just like DR's restore state event <a class="el" href="dr__events_8h.html#a89881448b9890f44ef26eab71014e956">dr_register_restore_state_ex_event()</a>, except that it is ordered according to <code>priority</code> among both extended and regular callbacks. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#ga0ffa6aa4d9af18a42e98d15b4f82bb20">drmgr_register_restore_state_event()</a> or <a class="el" href="group__drmgr.html#gaf52f88ecf793967022bddd447c65e66f">drmgr_register_restore_state_ex_event()</a>. Just like for DR, the first callback to return false will short-circuit event delivery to later callbacks. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga984ae18ed26a72c84a0fcaaaf44e2343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984ae18ed26a72c84a0fcaaaf44e2343">&#9670;&nbsp;</a></span>drmgr_register_signal_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_signal_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the signal event, which behaves just like DR's signal event <a class="el" href="dr__events_8h.html#a8f0c200ef1c92ac8bf43b1a62968838a">dr_register_signal_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga81409344987ecb2ffcf08370d4a1145d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81409344987ecb2ffcf08370d4a1145d">&#9670;&nbsp;</a></span>drmgr_register_signal_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_signal_event_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the signal event, which behaves just like DR's signal event <a class="el" href="dr__events_8h.html#a8f0c200ef1c92ac8bf43b1a62968838a">dr_register_signal_event()</a>, except that it is ordered according to <code>priority</code>. A default priority of 0 is used for events registered via <a class="el" href="group__drmgr.html#ga984ae18ed26a72c84a0fcaaaf44e2343">drmgr_register_signal_event()</a>. Just like for DR, the first callback to return other than DR_SIGNAL_DELIVER will short-circuit event delivery to later callbacks. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga86c57fb975df20d3583bb41c421f628d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86c57fb975df20d3583bb41c421f628d">&#9670;&nbsp;</a></span>drmgr_register_signal_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_signal_event_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the signal event, which behaves just like DR's module load event <a class="el" href="dr__events_8h.html#a8f0c200ef1c92ac8bf43b1a62968838a">dr_register_signal_event()</a>. Allows for the passing of user input <code>user_data</code>, which is available upon the execution of the callback. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga81409344987ecb2ffcf08370d4a1145d">drmgr_register_signal_event_ex()</a>. </p>

</div>
</div>
<a id="ga2d3e4b9d9e8cff8e8ec01ef44392cfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d3e4b9d9e8cff8e8ec01ef44392cfdd">&#9670;&nbsp;</a></span>drmgr_register_thread_exit_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread exit event. drmgr calls <code>func</code> whenever DR would, when an application thread exits. All the constraints of <a class="el" href="dr__events_8h.html#aa34d296a9e990925a096501a7d5c6596">dr_register_thread_exit_event()</a> apply. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga63e2e169d810174091e47364d53f18f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63e2e169d810174091e47364d53f18f5">&#9670;&nbsp;</a></span>drmgr_register_thread_exit_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_exit_event_ex </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread exit event, ordered by <code>priority</code>. drmgr calls <code>func</code> whenever DR would, when an application thread exits. All the constraints of <a class="el" href="dr__events_8h.html#aa34d296a9e990925a096501a7d5c6596">dr_register_thread_exit_event()</a> apply. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga2a0c6aabdbb08225f1d2fd605fd09f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a0c6aabdbb08225f1d2fd605fd09f81">&#9670;&nbsp;</a></span>drmgr_register_thread_exit_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_exit_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread exit event, ordered by <code>priority</code>. Allows for the passing of user data <code>user_data</code> which is available upon the execution of the callback. drmgr calls <code>func</code> when an application thread exits. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga63e2e169d810174091e47364d53f18f5">drmgr_register_thread_exit_event_ex()</a>. </p>

</div>
</div>
<a id="gaaac050cf70682f6fcb8e28aa942705cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaac050cf70682f6fcb8e28aa942705cd">&#9670;&nbsp;</a></span>drmgr_register_thread_init_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread initialization event. drmgr calls <code>func</code> whenever the application creates a new thread. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gaf5d894ba37e777790c9dec6f265892cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d894ba37e777790c9dec6f265892cb">&#9670;&nbsp;</a></span>drmgr_register_thread_init_event_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_init_event_ex </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread initialization event, ordered by <code>priority</code>. drmgr calls <code>func</code> whenever the application creates a new thread. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga798b4ae5da79d21d0e0b1a4eb962c950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga798b4ae5da79d21d0e0b1a4eb962c950">&#9670;&nbsp;</a></span>drmgr_register_thread_init_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_init_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad1ea8251bfe11bcc02821ada3852e599">drmgr_priority_t</a> *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread initialization event, ordered by <code>priority</code>. Allows for the passing of user data <code>user_data</code> which is available upon the execution of the callback. drmgr calls <code>func</code> whenever the application creates a new thread. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#gaf5d894ba37e777790c9dec6f265892cb">drmgr_register_thread_init_event_ex()</a>. </p>

</div>
</div>
<a id="ga512b4290d94b1874537e5b604cb27cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga512b4290d94b1874537e5b604cb27cab">&#9670;&nbsp;</a></span>drmgr_register_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT int drmgr_register_tls_field </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves a thread-local storage (tls) slot for every thread. Returns the index of the slot, which should be passed to <a class="el" href="group__drmgr.html#gade57b8de9ed73d579044aa8f12abfe8d">drmgr_get_tls_field()</a> and <a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field()</a>. Returns -1 if there are no more slots available. Each slot is initialized to NULL for each thread and should be properly initialized with <a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field()</a> in the thread initialization event (see <a class="el" href="dr__events_8h.html#a92ad96993c826232e76a56ff43cd31d0">dr_register_thread_init_event()</a>). </p>

</div>
</div>
<a id="ga057f980fa9323a0bb8a4226c7c52c14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga057f980fa9323a0bb8a4226c7c52c14a">&#9670;&nbsp;</a></span>drmgr_reserve_note_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT ptr_uint_t drmgr_reserve_note_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves <code>size</code> values in the namespace for use in the <code>note</code> field of instructions. The reserved range starts at the return value and is contiguous. Returns DRMGR_NOTE_NONE on failure. Un-reserving is not supported. </p>

</div>
</div>
<a id="ga5d3bc85402a8909c862d9c06d415f138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3bc85402a8909c862d9c06d415f138">&#9670;&nbsp;</a></span>drmgr_set_cls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_set_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user-controlled callback-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>. To generate an instruction sequence that writes the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#gaa1d2757949d817bae787612177c00d85">drmgr_insert_write_cls_field()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="gac92542bc4f09040f3085079e68d60f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac92542bc4f09040f3085079e68d60f66">&#9670;&nbsp;</a></span>drmgr_set_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_set_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user-controlled thread-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga512b4290d94b1874537e5b604cb27cab">drmgr_register_tls_field()</a>. To generate an instruction sequence that writes the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#ga65e2ae3d0f058fb069db7969e390c881">drmgr_insert_write_tls_field()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a id="ga22a83c67e54d71259e42b8e10abe62d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22a83c67e54d71259e42b8e10abe62d6">&#9670;&nbsp;</a></span>drmgr_unregister_bb_app2app_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_app2app_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters a callback function for the first instrumentation stage. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="ga85890ca6d143f6a5218680484a25d3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85890ca6d143f6a5218680484a25d3fb">&#9670;&nbsp;</a></span>drmgr_unregister_bb_insertion_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_insertion_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters <code>func</code> from the second and third instrumentation stages. If an analysis callback was passed to <a class="el" href="group__drmgr.html#ga83a5fc96944e10bd7356e0c492c93966">drmgr_register_bb_instrumentation_event()</a>, use <a class="el" href="group__drmgr.html#gaff08fa96e523f613b7371835c5025422">drmgr_unregister_bb_instrumentation_event()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="ga4c692eb44a082c09833d13ed85360814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c692eb44a082c09833d13ed85360814">&#9670;&nbsp;</a></span>drmgr_unregister_bb_instru2instru_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_instru2instru_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters a callback function for the fourth instrumentation stage. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="ga2bda2cd032c29f0a9343265cc9cdf6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bda2cd032c29f0a9343265cc9cdf6bd">&#9670;&nbsp;</a></span>drmgr_unregister_bb_instrumentation_all_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_instrumentation_all_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gaa610b2e06d4bae362405a7792b4060e3">drmgr_instru_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the callbacks that were registered via <a class="el" href="group__drmgr.html#ga4917fd1c3d667e52fc77b48d1325d85b">drmgr_register_bb_instrumentation_all_events()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="gaff08fa96e523f613b7371835c5025422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff08fa96e523f613b7371835c5025422">&#9670;&nbsp;</a></span>drmgr_unregister_bb_instrumentation_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_instrumentation_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga0c312b9deefda685e85620ed0c7c78d5">drmgr_analysis_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters <code>func</code> and its corresponding insertion callback from the second and third instrumentation stages. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="ga6980f5fdc8f1f74ecaca53d0ef49c16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6980f5fdc8f1f74ecaca53d0ef49c16a">&#9670;&nbsp;</a></span>drmgr_unregister_bb_instrumentation_ex_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_instrumentation_ex_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a>&#160;</td>
          <td class="paramname"><em>app2app_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a>&#160;</td>
          <td class="paramname"><em>analysis_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga13a6681d00526e2360f2a6b13f0272aa">drmgr_insertion_cb_t</a>&#160;</td>
          <td class="paramname"><em>insertion_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gad4983d7847f2c744a6e19fc9537f00ed">drmgr_ilist_ex_cb_t</a>&#160;</td>
          <td class="paramname"><em>instru2instru_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the four given callbacks that were registered via <a class="el" href="group__drmgr.html#ga26e4be9f62ffd954f2f95ba21ec92953">drmgr_register_bb_instrumentation_ex_event()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="ga216b449b7681a092557cc78b45895899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga216b449b7681a092557cc78b45895899">&#9670;&nbsp;</a></span>drmgr_unregister_bb_meta_instru_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_meta_instru_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga1260c94e5eb2b34a7af2c2e99b129568">drmgr_xform_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters a callback function for the fifth instrumentation stage. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="gaab638b9a9480b505e6ae323ffb72bb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab638b9a9480b505e6ae323ffb72bb1d">&#9670;&nbsp;</a></span>drmgr_unregister_cls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_cls_field </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, bool new_depth)&#160;</td>
          <td class="paramname"><em>cb_init_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, bool thread_exit)&#160;</td>
          <td class="paramname"><em>cb_exit_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a previously reserved callback-local storage (cls) slot index and unregisters its event callbacks. Returns false if the slot was not actually reserved. </p>

</div>
</div>
<a id="ga372a2681d2f9832639d5889f55132805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga372a2681d2f9832639d5889f55132805">&#9670;&nbsp;</a></span>drmgr_unregister_exception_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_exception_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, <a class="el" href="dr__events_8h.html#aa54aa75c24d4ba8dd5b8ceb2a9ba4f17">dr_exception_t</a> *excpt)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the exception event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga05c1d9997f1587ff4b690c3fc99a8244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c1d9997f1587ff4b690c3fc99a8244">&#9670;&nbsp;</a></span>drmgr_unregister_kernel_xfer_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_kernel_xfer_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__events_8h.html#a038cff5ceca3a723b477253c5f6057bf">dr_kernel_xfer_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the kernel transfer event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga29d5f9f8bf50ec7cfbc2ac1f7dff8820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29d5f9f8bf50ec7cfbc2ac1f7dff8820">&#9670;&nbsp;</a></span>drmgr_unregister_low_on_memory_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_low_on_memory_event </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the low-on-memory event. </p><dl class="section return"><dt>Returns</dt><dd>true if the unregistration of <code>func</code> is successful. </dd></dl>

</div>
</div>
<a id="ga8ed34155e0d54ee5464985ba8ba074d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ed34155e0d54ee5464985ba8ba074d9">&#9670;&nbsp;</a></span>drmgr_unregister_low_on_memory_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_low_on_memory_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function that accepts user-data for the low-on-memory event. </p><dl class="section return"><dt>Returns</dt><dd>true if the unregistration of <code>func</code> is successful. </dd></dl>

</div>
</div>
<a id="ga24be0b91d19115762643898a951d986e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24be0b91d19115762643898a951d986e">&#9670;&nbsp;</a></span>drmgr_unregister_module_load_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_module_load_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the module load event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga765dbfbaa6b6429ca35e2445d70badfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765dbfbaa6b6429ca35e2445d70badfc">&#9670;&nbsp;</a></span>drmgr_unregister_module_load_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_module_load_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, bool loaded, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function, which takes user data as a parameter for the module load event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga24be0b91d19115762643898a951d986e">drmgr_unregister_module_load_event()</a>. </p>

</div>
</div>
<a id="ga931bff986b8763df57f85b0f6cdfde58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga931bff986b8763df57f85b0f6cdfde58">&#9670;&nbsp;</a></span>drmgr_unregister_module_unload_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_module_unload_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the module unload event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="gaeb50301f40d7b84d7af3f7c3a4098629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb50301f40d7b84d7af3f7c3a4098629">&#9670;&nbsp;</a></span>drmgr_unregister_module_unload_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_module_unload_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="dr__defines_8h.html#af07dd10cb5378dc69117710c18f447e9">module_data_t</a> *info, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function, that takes user data as a parameter, for the module unload event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga931bff986b8763df57f85b0f6cdfde58">drmgr_unregister_module_unload_event()</a>. </p>

</div>
</div>
<a id="ga20ff5e38d676266d12f6641326bed87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20ff5e38d676266d12f6641326bed87a">&#9670;&nbsp;</a></span>drmgr_unregister_opcode_instrumentation_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_opcode_instrumentation_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga4895c7d1731eae3076179b3aa7364343">drmgr_opcode_insertion_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the opcode-specific callback that was registered via <a class="el" href="group__drmgr.html#ga14834254df9e9ded4369063e5cfba909">drmgr_register_opcode_instrumentation_event()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered for the passed opcode <code>opcode</code>).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#a9c2ce8d64301f81084dddb3bf2ddbbf6">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a id="ga79da54157fa3651e28dca9a9beda358a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79da54157fa3651e28dca9a9beda358a">&#9670;&nbsp;</a></span>drmgr_unregister_post_syscall_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_post_syscall_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the post-syscall event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga2289eab1f61abd920c2c9e0b79d9a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2289eab1f61abd920c2c9e0b79d9a7c9">&#9670;&nbsp;</a></span>drmgr_unregister_post_syscall_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_post_syscall_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function, which takes user data, for the post-syscall event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga79da54157fa3651e28dca9a9beda358a">drmgr_unregister_post_syscall_event()</a>. </p>

</div>
</div>
<a id="ga7b437d862c741e995a75dc2d59ed6e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b437d862c741e995a75dc2d59ed6e43">&#9670;&nbsp;</a></span>drmgr_unregister_pre_syscall_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_pre_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the pre-syscall event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga762e86ccf9fc30cc82d333f436531261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762e86ccf9fc30cc82d333f436531261">&#9670;&nbsp;</a></span>drmgr_unregister_pre_syscall_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_pre_syscall_event_user_data </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function, which takes user data, for the pre-syscall event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga7b437d862c741e995a75dc2d59ed6e43">drmgr_unregister_pre_syscall_event()</a>. </p>

</div>
</div>
<a id="ga55534858a00937feec337f7ca66c3c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55534858a00937feec337f7ca66c3c9e">&#9670;&nbsp;</a></span>drmgr_unregister_restore_state_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_restore_state_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#ab55fe2529e760adfd88197d0246bc074">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the restore state event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga5f56b07ef2216961d6d01bd06bd907ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f56b07ef2216961d6d01bd06bd907ec">&#9670;&nbsp;</a></span>drmgr_unregister_restore_state_ex_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_restore_state_ex_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, bool restore_memory, <a class="el" href="dr__events_8h.html#a7b60f2254adf92bc99ebd248f76044fe">dr_restore_state_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the restore state extended event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga617ad3a9ed87404feb3c6afe92b81ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617ad3a9ed87404feb3c6afe92b81ad6">&#9670;&nbsp;</a></span>drmgr_unregister_signal_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_signal_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the signal event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga75e39e277cba48e60006ecd5bb4cad8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75e39e277cba48e60006ecd5bb4cad8f">&#9670;&nbsp;</a></span>drmgr_unregister_signal_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_signal_event_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="dr__events_8h.html#a5387c3c355661ff049c4480e55ca6633">dr_siginfo_t</a> *siginfo, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the signal event which also has user data passed to the callback. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga617ad3a9ed87404feb3c6afe92b81ad6">drmgr_unregister_signal_event()</a>. </p>

</div>
</div>
<a id="ga1a83a4ecf1b6172eab85e116aef96bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a83a4ecf1b6172eab85e116aef96bea">&#9670;&nbsp;</a></span>drmgr_unregister_thread_exit_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_thread_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the thread exit event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga587650c7772d977480861daa39911d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga587650c7772d977480861daa39911d22">&#9670;&nbsp;</a></span>drmgr_unregister_thread_exit_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_thread_exit_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the thread exit event which also has user data passed to the callback. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga1a83a4ecf1b6172eab85e116aef96bea">drmgr_unregister_thread_exit_event()</a>. </p>

</div>
</div>
<a id="ga835120bfe4726d59d13f8fbcd01fb264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga835120bfe4726d59d13f8fbcd01fb264">&#9670;&nbsp;</a></span>drmgr_unregister_thread_init_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_thread_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the thread initialization event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a id="ga45210f010c66f233c8580aa1f58a294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45210f010c66f233c8580aa1f58a294c">&#9670;&nbsp;</a></span>drmgr_unregister_thread_init_event_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_thread_init_event_user_data </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *user_data)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the thread initialization event which also has user data passed to the callback. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>See also <a class="el" href="group__drmgr.html#ga835120bfe4726d59d13f8fbcd01fb264">drmgr_unregister_thread_init_event()</a>. </p>

</div>
</div>
<a id="ga0389d904f0e656f8a8777d850e6187f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0389d904f0e656f8a8777d850e6187f3">&#9670;&nbsp;</a></span>drmgr_unregister_tls_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_tls_field </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a previously reserved thread-local storage (tls) slot index. Returns false if the slot was not actually reserved. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:58 &nbsp; <img border=0 src="favicon.png">
</small></address>
