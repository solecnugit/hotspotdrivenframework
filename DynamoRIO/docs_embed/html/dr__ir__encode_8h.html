---
title: "/include/dr_ir_encode.h File Reference"
layout: default
permalink: /dr__ir__encode_8h.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43e0a1f539e00dcfa1a6bc4d4fee4fc2.html">home</a></li><li class="navelem"><a class="el" href="dir_1036706e55c22cab35bc1c58ee689f1d.html">runner</a></li><li class="navelem"><a class="el" href="dir_629f8151d55d307162ff2d619fb1783d.html">work</a></li><li class="navelem"><a class="el" href="dir_84b917e355554dd3f3793c21ab4ddcaf.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_afee7b8fe0b60d0be677a736c14882ae.html">dynamorio</a></li><li class="navelem"><a class="el" href="dir_489b6e853deb4fa1d1f97a1bc0ffc492.html">build_release-64</a></li><li class="navelem"><a class="el" href="dir_7d0abe6c542863e2b7fbc044a2f4f0d7.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_ir_encode.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encoding routines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1ab4eb589819195ae2674b22546e3b4a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a></td></tr>
<tr class="separator:a1ab4eb589819195ae2674b22546e3b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a00e03b2e5e75a83eacf9a0ee1674074a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a> { <br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa4216aed26374dfaaf5b8e64c8bfc9c6c">DR_ISA_IA32</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa6bec3bf2d3d264dfa7dbf67d18b47c41">DR_ISA_X86</a> = DR_ISA_IA32, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aabd60fe0abfbb90ba431205b7e5345ac0">DR_ISA_AMD64</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa28dc5f6ff81766706362bfb7494a0494">DR_ISA_ARM_A32</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc">DR_ISA_ARM_THUMB</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aaefbc35f57a99a1464fda9d6d75dd8445">DR_ISA_ARM_A64</a>
<br />
 }</td></tr>
<tr class="separator:a00e03b2e5e75a83eacf9a0ee1674074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae796d2ff6eabe43904b17742deafd637"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#ae796d2ff6eabe43904b17742deafd637">dr_set_isa_mode</a> (void *drcontext, <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> new_mode, <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> *old_mode OUT)</td></tr>
<tr class="separator:ae796d2ff6eabe43904b17742deafd637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f9b08f90490fbeae26d12a461af084"><td class="memItemLeft" align="right" valign="top">DR_API <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#ae8f9b08f90490fbeae26d12a461af084">dr_get_isa_mode</a> (void *drcontext)</td></tr>
<tr class="separator:ae8f9b08f90490fbeae26d12a461af084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f1d03e4c63cece35113e6cc04fb2cc"><td class="memItemLeft" align="right" valign="top">DR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#af7f1d03e4c63cece35113e6cc04fb2cc">instr_is_encoding_possible</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:af7f1d03e4c63cece35113e6cc04fb2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d194e7ce235e330a28686db29ee5480"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a3d194e7ce235e330a28686db29ee5480">instr_encode</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr class="separator:a3d194e7ce235e330a28686db29ee5480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a9fb1eaa589b9bb143c8c85861b2b"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a285a9fb1eaa589b9bb143c8c85861b2b">instr_encode_to_copy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *copy_pc, byte *final_pc)</td></tr>
<tr class="separator:a285a9fb1eaa589b9bb143c8c85861b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d414952f335eaee8221c2a0e65ea46"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, byte *pc, bool has_instr_jmp_targets)</td></tr>
<tr class="separator:a04d414952f335eaee8221c2a0e65ea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eacc8e4f757c7d3ed0e29f464021522"><td class="memItemLeft" align="right" valign="top">DR_API byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__encode_8h.html#a8eacc8e4f757c7d3ed0e29f464021522">instrlist_encode_to_copy</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *ilist, byte *copy_pc, byte *final_pc, byte *max_pc, bool has_instr_jmp_targets)</td></tr>
<tr class="separator:a8eacc8e4f757c7d3ed0e29f464021522"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encoding routines. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a1ab4eb589819195ae2674b22546e3b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab4eb589819195ae2674b22546e3b4a">&#9670;&nbsp;</a></span>dr_isa_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a> <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies which processor mode to use when decoding or encoding. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a00e03b2e5e75a83eacf9a0ee1674074a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e03b2e5e75a83eacf9a0ee1674074a">&#9670;&nbsp;</a></span>_dr_isa_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074a">_dr_isa_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies which processor mode to use when decoding or encoding. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa4216aed26374dfaaf5b8e64c8bfc9c6c"></a>DR_ISA_IA32&#160;</td><td class="fielddoc"><p>IA-32 (Intel/AMD 32-bit mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa6bec3bf2d3d264dfa7dbf67d18b47c41"></a>DR_ISA_X86&#160;</td><td class="fielddoc"><p>Alias for DR_ISA_IA32. </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aabd60fe0abfbb90ba431205b7e5345ac0"></a>DR_ISA_AMD64&#160;</td><td class="fielddoc"><p>AMD64 (Intel/AMD 64-bit mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa28dc5f6ff81766706362bfb7494a0494"></a>DR_ISA_ARM_A32&#160;</td><td class="fielddoc"><p>ARM A32 (AArch32 ARM). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aa3f721209faa0616ff181a7bf207a59cc"></a>DR_ISA_ARM_THUMB&#160;</td><td class="fielddoc"><p>Thumb (ARM T32). </p>
</td></tr>
<tr><td class="fieldname"><a id="a00e03b2e5e75a83eacf9a0ee1674074aaefbc35f57a99a1464fda9d6d75dd8445"></a>DR_ISA_ARM_A64&#160;</td><td class="fielddoc"><p>ARM A64 (AArch64). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae8f9b08f90490fbeae26d12a461af084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f9b08f90490fbeae26d12a461af084">&#9670;&nbsp;</a></span>dr_get_isa_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API <a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> dr_get_isa_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates which processor mode to use. This routine returns the value of that flag. </p>

</div>
</div>
<a id="ae796d2ff6eabe43904b17742deafd637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae796d2ff6eabe43904b17742deafd637">&#9670;&nbsp;</a></span>dr_set_isa_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool dr_set_isa_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a>&#160;</td>
          <td class="paramname"><em>new_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__encode_8h.html#a1ab4eb589819195ae2674b22546e3b4a">dr_isa_mode_t</a> *old_mode&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates which processor mode to use. This routine sets that flag to the indicated value and optionally returns the old value. Be sure to restore the old value prior to any further application execution to avoid problems in mis-interpreting application code. </p>

</div>
</div>
<a id="a3d194e7ce235e330a28686db29ee5480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d194e7ce235e330a28686db29ee5480">&#9670;&nbsp;</a></span>instr_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instr_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>pc</code>. Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p><dl class="section note"><dt>Note</dt><dd>: In Thumb mode, some instructions have different behavior depending on whether they are in an IT block. To correctly encode such instructions, they should be encoded within an instruction list with the corresponding IT instruction using <a class="el" href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode()</a>. </dd></dl>

</div>
</div>
<a id="a285a9fb1eaa589b9bb143c8c85861b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285a9fb1eaa589b9bb143c8c85861b2b">&#9670;&nbsp;</a></span>instr_encode_to_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instr_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>final_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative component is encoded as though the instruction were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p><dl class="section note"><dt>Note</dt><dd>: In Thumb mode, some instructions have different behavior depending on whether they are in an IT block. To correctly encode such instructions, they should be encoded within an instruction list with the corresponding IT instruction using <a class="el" href="dr__ir__encode_8h.html#a04d414952f335eaee8221c2a0e65ea46">instrlist_encode()</a>. </dd></dl>

</div>
</div>
<a id="af7f1d03e4c63cece35113e6cc04fb2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f1d03e4c63cece35113e6cc04fb2cc">&#9670;&nbsp;</a></span>instr_is_encoding_possible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API bool instr_is_encoding_possible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> can be encoded as</p><ul>
<li>a valid IA-32 instruction on X86</li>
<li>a valid Armv8-a instruction on AArch64 (Note: The AArch64 encoder/decoder is not complete yet, so DynamoRIO may fail to encode some valid Armv8-a instructions)</li>
<li>a valid Armv7 instruction on ARM </li>
</ul>

</div>
</div>
<a id="a04d414952f335eaee8221c2a0e65ea46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d414952f335eaee8221c2a0e65ea46">&#9670;&nbsp;</a></span>instrlist_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instrlist_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_instr_jmp_targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes each instruction in <code>ilist</code> in turn in contiguous memory starting at <code>pc</code>. Returns the pc after all of the encodings, or NULL if any one of the encodings failed. Uses the x86/x64 mode stored in each instr, not the mode of the current thread. In order for <a class="el" href="structinstr__t.html">instr_t</a> operands to be encoded properly, <code>has_instr_jmp_targets</code> must be true. If <code>has_instr_jmp_targets</code> is true, the note field of each <a class="el" href="structinstr__t.html">instr_t</a> in ilist will be overwritten, and if any <a class="el" href="structinstr__t.html">instr_t</a> targets are not in <code>ilist</code>, they must have their note fields set with their offsets relative to pc. x86 instructions can occupy up to 17 bytes each, so the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a id="a8eacc8e4f757c7d3ed0e29f464021522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eacc8e4f757c7d3ed0e29f464021522">&#9670;&nbsp;</a></span>instrlist_encode_to_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_API byte* instrlist_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a3fb73c55def575ec5705577625491d66">instrlist_t</a> *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>final_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>max_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_instr_jmp_targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes each instruction in <code>ilist</code> in turn in contiguous memory starting <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative instruction is encoded as though the instruction list were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Returns the pc after all of the encodings, or NULL if any one of the encodings failed.</p>
<p>Uses the x86/x64 mode stored in each instr, not the mode of the current thread.</p>
<p>In order for <a class="el" href="structinstr__t.html">instr_t</a> operands to be encoded properly, <code>has_instr_jmp_targets</code> must be true. If <code>has_instr_jmp_targets</code> is true, the note field of each <a class="el" href="structinstr__t.html">instr_t</a> in ilist will be overwritten, and if any <a class="el" href="structinstr__t.html">instr_t</a> targets are not in <code>ilist</code>, they must have their note fields set with their offsets relative to pc.</p>
<p>If <code>max_pc</code> is non-NULL, computes the total size required to encode the instruction list before performing any encoding. If the whole list will not fit starting at <code>copy_pc</code> without exceeding <code>max_pc</code>, returns NULL without encoding anything. Otherwise encodes as normal. Note that x86 instructions can occupy up to 17 bytes each, so if <code>max_pc</code> is NULL, the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.0.1 --- Mon Feb 14 2022 19:02:55 &nbsp; <img border=0 src="favicon.png">
</small></address>
